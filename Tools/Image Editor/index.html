<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Editor</title>
    <style>
        :root {
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --light-bg-opaque: #f8f9fa;
            --dark-bg-opaque: #2c3e50;
            --panel-bg-opaque: #ffffff;
            --dark-panel-bg-opaque: #34495e;
            --light-bg-transparent: rgba(248, 249, 250, 0.82);
            --dark-bg-transparent: rgba(44, 62, 80, 0.82);
            --panel-bg-transparent: rgba(255, 255, 255, 0.88);
            --dark-panel-bg-transparent: rgba(52, 73, 94, 0.88);
            --light-bg: var(--light-bg-transparent);
            --dark-bg: var(--dark-bg-transparent);
            --panel-bg: var(--panel-bg-transparent);
            --light-text: #212529;
            --dark-text: #ecf0f1;
            --border-color: #dee2e6;
            --dark-border-color: #455a64;
            --button-text-color: #fff;
            --input-bg: #fff;
            --dark-input-bg: #566573;
            --input-border: #ced4da;
            --dark-input-border: #76838f;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh;
            color: var(--light-text); transition: color 0.3s; position: relative; overflow: hidden;
        }
        body::before {
            content: ""; position: fixed; left: 0; top: 0; width: 100%; height: 100%;
            background-image: url('main.avif'); background-size: cover; background-position: center;
            filter: blur(0px); z-index: -1;
        }
        body.dark-mode {
            color: var(--dark-text); --panel-bg: var(--dark-panel-bg-transparent);
            --border-color: var(--dark-border-color); --input-bg: var(--dark-input-bg);
            --input-border: var(--dark-input-border);
        }
        .container { display: flex; flex-grow: 1; overflow: hidden; }
        .controls-panel {
            width: 280px; padding: 20px; background-color: var(--panel-bg);
            border-right: 1px solid var(--border-color); overflow-y: auto; display: flex;
            flex-direction: column; gap: 8px; transition: background-color 0.3s, border-color 0.3s;
        }
        .control-group, .cropping-controls-panel { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .control-group:last-child, .cropping-controls-panel:last-child { border-bottom: none; }
        .control-group h3, .cropping-controls-panel h3 {
            margin-top: 0; margin-bottom: 10px; font-size: 1.1em; color: var(--primary-color);
        }
        body.dark-mode .control-group h3, body.dark-mode .cropping-controls-panel h3 { color: #5dade2; }
        .controls-panel button, .controls-panel select, .controls-panel input[type="file"]::file-selector-button {
            display: block; width: 100%; padding: 10px 15px; margin-bottom: 8px;
            background-color: var(--primary-color); color: var(--button-text-color); border: none;
            border-radius: 5px; cursor: pointer; font-size: 0.95em;
            transition: background-color 0.2s ease; box-sizing: border-box;
        }
        .controls-panel input[type="file"] { padding: 0; }
        .controls-panel button:hover, .controls-panel input[type="file"]::file-selector-button:hover { background-color: var(--primary-hover); }
        .controls-panel button:disabled { background-color: #ccc; cursor: not-allowed; }
        body.dark-mode .controls-panel button:disabled { background-color: #555; color: #999; }
        .controls-panel select {
            background-color: var(--input-bg); color: var(--light-text); border: 1px solid var(--input-border);
        }
        body.dark-mode .controls-panel select {
            background-color: var(--dark-input-bg); color: var(--dark-text); border: 1px solid var(--dark-input-border);
        }
        .controls-panel label { display: block; margin-bottom: 5px; font-size: 0.9em; }
        .controls-panel input[type="range"] { width: 100%; margin-bottom: 10px; }
        .image-display-area {
            flex-grow: 1; padding: 20px; display: flex; justify-content: center; align-items: center;
            background-color: var(--light-bg); position: relative; transition: background-color 0.3s;
        }
        body.dark-mode .image-display-area { background-color: var(--dark-bg); }
        #imageCanvas {
            max-width: 100%; max-height: 100%; object-fit: contain;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 1px solid var(--border-color);
        }
        body.dark-mode #imageCanvas {
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 1px solid var(--dark-border-color);
        }
        #imageCanvas.is-cropping { cursor: crosshair; }
        #noImageText { color: #888; font-size: 1.2em; }
        body.dark-mode #noImageText { color: #aaa; }
        .status-bar {
            padding: 8px 20px; background-color: var(--panel-bg); border-top: 1px solid var(--border-color);
            font-size: 0.9em; color: var(--light-text); display: flex; justify-content: space-between;
            align-items: center; transition: background-color 0.3s, border-color 0.3s, color 0.3s;
        }
        .status-bar-controls { display: flex; align-items: center; gap: 15px; }
        .status-bar-controls > select, .status-bar-controls > button, .status-bar-controls > a {
             padding: 5px 10px;
             background-color: var(--primary-color);
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
             text-decoration: none;
        }
        .status-bar-controls > select:hover, .status-bar-controls > button:hover, .status-bar-controls > a:hover {
            background-color: var(--primary-hover);
        }
        .status-bar select { border: 1px solid var(--primary-color); }
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.5); justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--panel-bg-opaque); color: var(--light-text); margin: auto; padding: 20px;
            border: 1px solid var(--border-color); border-radius: 8px; width: 80%; max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2); transition: background-color 0.3s, border-color 0.3s, color 0.3s;
        }
        body.dark-mode .modal-content {
            background-color: var(--dark-panel-bg-opaque); color: var(--dark-text); border-color: var(--dark-border-color);
        }
        .modal-content h4 { margin-top: 0;}
        .modal-content input[type="number"] {
            width: calc(100% - 22px); padding: 10px; margin-bottom: 15px; border: 1px solid var(--input-border);
            border-radius: 4px; background-color: var(--input-bg); color: var(--light-text);
        }
        body.dark-mode .modal-content input[type="number"] {
            background-color: var(--dark-input-bg); color: var(--dark-text); border-color: var(--dark-input-border);
        }
        .modal-buttons { text-align: right; margin-top: 15px; }
        .modal-buttons button { padding: 8px 15px; margin-left: 10px; border-radius: 4px; cursor: pointer; }
        .modal-btn-confirm { background-color: var(--primary-color); color: white; border: none; }
        .modal-btn-confirm:hover { background-color: var(--primary-hover); }
        .modal-btn-cancel { background-color: #6c757d; color: white; border: none; }
        body.dark-mode .modal-btn-cancel { background-color: #545b62; }
        .preset-buttons-container { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .preset-buttons-container h5 { margin-top: 0; margin-bottom: 10px; font-weight: 600; }
        .preset-buttons { display: flex; flex-wrap: wrap; gap: 8px; }
        .preset-btn {
            padding: 6px 12px; font-size: 0.85em; background-color: #e9ecef; color: #495057;
            border: 1px solid #ced4da; border-radius: 4px; cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .preset-btn:hover { background-color: #dee2e6; border-color: #adb5bd; }
        body.dark-mode .preset-btn { background-color: #495057; color: #e9ecef; border: 1px solid #6c757d; }
        body.dark-mode .preset-btn:hover { background-color: #5a6268; border-color: #78828a; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div class="container">
        <aside class="controls-panel">
            <div id="main-controls">
                <div class="control-group">
                    <h3 data-translate-key="file">File</h3>
                    <input type="file" id="loadImageInput" accept="image/*" style="display: none;">
                    <button id="btnLoadTrigger" data-translate-key="loadImage">Load Image</button>
                    <button id="btnSave" disabled data-translate-key="saveImage">Save Image</button>
                    <button id="btnSaveAs" disabled data-translate-key="saveAs">Save As...</button>
                    <button id="btnReset" disabled data-translate-key="resetImage">Reset Image</button>
                </div>
                <div class="control-group">
                    <h3 data-translate-key="operations">Operations</h3>
                    <button id="btnResize" disabled data-translate-key="resize">Resize</button>
                    <button id="btnCrop" disabled data-translate-key="crop">Crop</button>
                    <button id="btnRotate" disabled data-translate-key="rotate">Rotate</button>
                    <button id="btnGrayscale" disabled data-translate-key="grayscale">Grayscale</button>
                </div>
                <div class="control-group">
                    <h3 data-translate-key="filters">Filters</h3>
                    <select id="filterSelect" disabled>
                        <option value="none" data-translate-key="noFilter">No Filter</option>
                        <option value="blur" data-translate-key="blurFilter">BLUR</option>
                        <option value="sharpen" data-translate-key="sharpenFilter">SHARPEN (Basic)</option>
                        <option value="smooth" data-translate-key="smoothFilter">SMOOTH (Blur)</option>
                    </select>
                </div>
                <div class="control-group">
                    <h3 data-translate-key="adjustments">Adjustments</h3>
                    <label for="brightnessSlider"><span data-translate-key="brightness">Brightness</span>: <span id="brightnessValue">100</span>%</label>
                    <input type="range" id="brightnessSlider" min="0" max="300" value="100" disabled>
                    <label for="contrastSlider"><span data-translate-key="contrast">Contrast</span>: <span id="contrastValue">100</span>%</label>
                    <input type="range" id="contrastSlider" min="0" max="300" value="100" disabled>
                </div>
            </div>
            
            <div id="cropping-controls-panel" class="cropping-controls-panel hidden">
                <h3 data-translate-key="cropImage">Crop Image</h3>
                <div class="preset-buttons-container" style="border-bottom: none; padding-bottom: 0;">
                    <h5 data-translate-key="aspectRatio">Aspect Ratio</h5>
                    <div id="cropPresetButtons" class="preset-buttons">
                        <button type="button" class="preset-btn" data-ratio="free" data-translate-key="ratioFree">Free</button>
                        <button type="button" class="preset-btn" data-ratio="1" data-translate-key="ratio1_1">1:1</button>
                        <button type="button" class="preset-btn" data-ratio="1.777" data-translate-key="ratio16_9">16:9</button>
                        <button type="button" class="preset-btn" data-ratio="1.333" data-translate-key="ratio4_3">4:3</button>
                    </div>
                </div>
                <button id="btnCropConfirm" data-translate-key="confirmCrop">Confirm Crop</button>
                <button id="btnCropCancel" data-translate-key="cancel" style="background-color: #6c757d;">Cancel</button>
            </div>
        </aside>

        <main class="image-display-area">
            <canvas id="imageCanvas"></canvas>
            <p id="noImageText" data-translate-key="noImageLoaded">No image loaded.</p>
        </main>
    </div>

    <footer class="status-bar">
        <span id="statusText">Ready.</span>
        <div class="status-bar-controls">
            <a href="https://tiwut.de" target="_blank" rel="noopener noreferrer" data-translate-key="visitTiwut">Main Page</a>
            <select id="languageSelector"></select>
            <button id="themeToggle" data-translate-key="toggleTheme">Toggle Dark/Light Mode</button>
        </div>
    </footer>

    <div id="resizeModal" class="modal">
        <div class="modal-content">
            <h4 data-translate-key="resizeModalTitle">Resize Image</h4>
            <p id="currentSizeText">Current: N/A</p>
            <div class="preset-buttons-container">
                <h5 data-translate-key="resizePresetsTitle">Presets</h5>
                <div id="resizePresetButtons" class="preset-buttons">
                    <button type="button" class="preset-btn" data-preset="50%" data-translate-key="preset_50">50%</button>
                    <button type="button" class="preset-btn" data-preset="25%" data-translate-key="preset_25">25%</button>
                    <button type="button" class="preset-btn" data-preset="1080x1080" data-translate-key="preset_1080x1080">Square (1080p)</button>
                    <button type="button" class="preset-btn" data-preset="1080x1920" data-translate-key="preset_1080x1920">Story (1080p)</button>
                </div>
            </div>
            <label for="newWidth" data-translate-key="newWidth">New Width:</label>
            <input type="number" id="newWidth" min="1">
            <label for="newHeight" data-translate-key="newHeight">New Height:</label>
            <input type="number" id="newHeight" min="1">
            <div class="modal-buttons">
                <button id="btnResizeCancel" class="modal-btn-cancel" data-translate-key="cancel">Cancel</button>
                <button id="btnResizeConfirm" class="modal-btn-confirm" data-translate-key="resizeButton">Resize</button>
            </div>
        </div>
    </div>

    <div id="rotateModal" class="modal">
        <div class="modal-content">
            <h4 data-translate-key="rotateModalTitle">Rotate Image</h4>
            <label for="rotationAngle" data-translate-key="rotationAngle">Angle (degrees, counter-clockwise):</label>
            <input type="number" id="rotationAngle" value="90" step="1">
            <div class="modal-buttons">
                <button id="btnRotateCancel" class="modal-btn-cancel" data-translate-key="cancel">Cancel</button>
                <button id="btnRotateConfirm" class="modal-btn-confirm" data-translate-key="rotateButton">Rotate</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const translations = {
                en: {
                    langName: "English",
                    file: "File", loadImage: "Load Image", saveImage: "Save Image", saveAs: "Save As...", resetImage: "Reset Image",
                    operations: "Operations", resize: "Resize", crop: "Crop", rotate: "Rotate", grayscale: "Grayscale",
                    filters: "Filters", noFilter: "No Filter", blurFilter: "BLUR", sharpenFilter: "SHARPEN (Basic)", smoothFilter: "SMOOTH (Blur)",
                    adjustments: "Adjustments", brightness: "Brightness", contrast: "Contrast",
                    noImageLoaded: "No image loaded.",
                    statusReady: "Ready.", statusLoadPrompt: "Ready. Load an image to start.",
                    statusImageInfo: (name, w, h, rot) => `Image: ${name} (${w}x${h}) Rotated: ${rot}°`,
                    statusCropping: "Draw a rectangle to crop. Press 'Confirm Crop' to apply.",
                    toggleTheme: "Toggle Dark/Light",
                    resizeModalTitle: "Resize Image", currentSize: "Current", newWidth: "New Width:", newHeight: "New Height:",
                    resizePresetsTitle: "Presets", preset_50: "50%", preset_25: "25%", preset_1080x1080: "Square (1080p)", preset_1080x1920: "Story (1080p)",
                    cancel: "Cancel", resizeButton: "Resize",
                    rotateModalTitle: "Rotate Image", rotationAngle: "Angle (degrees, counter-clockwise):", rotateButton: "Rotate",
                    cropImage: "Crop Image", aspectRatio: "Aspect Ratio", ratioFree: "Free", ratio1_1: "1:1 Square", ratio16_9: "16:9", ratio4_3: "4:3",
                    confirmCrop: "Confirm Crop",
                    visitTiwut: "Main Page",
                    promptSaveAs: "Enter new file name (e.g., image.png or image.jpg):",
                    alertImageSaved: (name) => `Image saved as ${name}.`,
                    alertImageReset: "Image has been reset to its original state.",
                    alertNoImageToSave: "No image to save.",
                    errorPrefix: "Error",
                    errorLoad: "Could not load image. The file might be corrupted or an unsupported format.",
                    errorReadFile: "Failed to read file.",
                    errorProcessImage: "Failed to process image for redrawing.",
                    errorResize: "Failed to resize image.",
                    errorResizeValues: "Width and Height must be positive values.",
                    errorInvalidAngle: "Invalid angle. Please enter a number."
                },
                de: {
                    langName: "Deutsch",
                    file: "Datei", loadImage: "Bild laden", saveImage: "Bild speichern", saveAs: "Speichern unter...", resetImage: "Bild zurücksetzen",
                    operations: "Operationen", resize: "Größe ändern", crop: "Zuschneiden", rotate: "Drehen", grayscale: "Graustufen",
                    filters: "Filter", noFilter: "Kein Filter", blurFilter: "WEICHZEICHNEN", sharpenFilter: "SCHÄRFEN (Einfach)", smoothFilter: "GLÄTTEN (Weichz.)",
                    adjustments: "Anpassungen", brightness: "Helligkeit", contrast: "Kontrast",
                    noImageLoaded: "Kein Bild geladen.",
                    statusReady: "Bereit.", statusLoadPrompt: "Bereit. Laden Sie ein Bild, um zu beginnen.",
                    statusImageInfo: (name, w, h, rot) => `Bild: ${name} (${w}x${h}) Gedreht: ${rot}°`,
                    statusCropping: "Zeichnen Sie ein Rechteck zum Zuschneiden. Drücken Sie 'Zuschneiden bestätigen' zum Anwenden.",
                    toggleTheme: "Modus wechseln",
                    resizeModalTitle: "Bildgröße ändern", currentSize: "Aktuell", newWidth: "Neue Breite:", newHeight: "Neue Höhe:",
                    resizePresetsTitle: "Voreinstellungen", preset_50: "50%", preset_25: "25%", preset_1080x1080: "Quadrat (1080p)", preset_1080x1920: "Story (1080p)",
                    cancel: "Abbrechen", resizeButton: "Anwenden",
                    rotateModalTitle: "Bild drehen", rotationAngle: "Winkel (Grad, gegen den Uhrzeigersinn):", rotateButton: "Drehen",
                    cropImage: "Bild zuschneiden", aspectRatio: "Seitenverhältnis", ratioFree: "Frei", ratio1_1: "1:1 Quadrat", ratio16_9: "16:9", ratio4_3: "4:3",
                    confirmCrop: "Zuschneiden bestätigen",
                    visitTiwut: "Main Page",
                    promptSaveAs: "Neuen Dateinamen eingeben (z.B. bild.png oder bild.jpg):",
                    alertImageSaved: (name) => `Bild als ${name} gespeichert.`,
                    alertImageReset: "Das Bild wurde auf den Originalzustand zurückgesetzt.",
                    alertNoImageToSave: "Kein Bild zum Speichern vorhanden.",
                    errorPrefix: "Fehler",
                    errorLoad: "Bild konnte nicht geladen werden. Die Datei ist möglicherweise beschädigt oder hat ein nicht unterstütztes Format.",
                    errorReadFile: "Datei konnte nicht gelesen werden.",
                    errorProcessImage: "Fehler bei der Bildverarbeitung zum Neuzeichnen.",
                    errorResize: "Größenänderung des Bildes fehlgeschlagen.",
                    errorResizeValues: "Breite und Höhe müssen positive Werte sein.",
                    errorInvalidAngle: "Ungültiger Winkel. Bitte geben Sie eine Zahl ein."
                },
                es: {
                    langName: "Español",
                    file: "Archivo", loadImage: "Cargar imagen", saveImage: "Guardar imagen", saveAs: "Guardar como...", resetImage: "Restablecer imagen",
                    operations: "Operaciones", resize: "Cambiar tamaño", crop: "Recortar", rotate: "Girar", grayscale: "Escala de grises",
                    filters: "Filtros", noFilter: "Sin filtro", blurFilter: "DESENFOCAR", sharpenFilter: "ENFOCAR (Básico)", smoothFilter: "SUAVIZAR (Desenfoque)",
                    adjustments: "Ajustes", brightness: "Brillo", contrast: "Contraste",
                    noImageLoaded: "No se ha cargado ninguna imagen.",
                    statusReady: "Listo.", statusLoadPrompt: "Listo. Carga una imagen para empezar.",
                    statusImageInfo: (name, w, h, rot) => `Imagen: ${name} (${w}x${h}) Girado: ${rot}°`,
                    statusCropping: "Dibuja un rectángulo para recortar. Pulsa 'Confirmar recorte' para aplicar.",
                    toggleTheme: "Cambiar modo",
                    resizeModalTitle: "Cambiar tamaño de imagen", currentSize: "Actual", newWidth: "Nueva anchura:", newHeight: "Nueva altura:",
                    resizePresetsTitle: "Ajustes preestablecidos", preset_50: "50%", preset_25: "25%", preset_1080x1080: "Cuadrado (1080p)", preset_1080x1920: "Historia (1080p)",
                    cancel: "Cancelar", resizeButton: "Aplicar",
                    rotateModalTitle: "Girar imagen", rotationAngle: "Ángulo (grados, antihorario):", rotateButton: "Girar",
                    cropImage: "Recortar imagen", aspectRatio: "Relación de aspecto", ratioFree: "Libre", ratio1_1: "1:1 Cuadrado", ratio16_9: "16:9", ratio4_3: "4:3",
                    confirmCrop: "Confirmar recorte",
                    visitTiwut: "Main Page",
                    promptSaveAs: "Introduce el nuevo nombre del archivo (p. ej., imagen.png o imagen.jpg):",
                    alertImageSaved: (name) => `Imagen guardada como ${name}.`,
                    alertImageReset: "La imagen ha sido restablecida a su estado original.",
                    alertNoImageToSave: "No hay imagen para guardar.",
                    errorPrefix: "Error",
                    errorLoad: "No se pudo cargar la imagen. El archivo puede estar dañado o en un formato no compatible.",
                    errorReadFile: "Error al leer el archivo.",
                    errorProcessImage: "Error al procesar la imagen para redibujar.",
                    errorResize: "Error al cambiar el tamaño de la imagen.",
                    errorResizeValues: "La anchura y la altura deben ser valores positivos.",
                    errorInvalidAngle: "Ángulo inválido. Por favor, introduce un número."
                }
            };
            let currentLanguage = 'en';

            const mainControls = document.getElementById('main-controls');
            const croppingControlsPanel = document.getElementById('cropping-controls-panel');
            const btnCrop = document.getElementById('btnCrop');
            const btnCropConfirm = document.getElementById('btnCropConfirm');
            const btnCropCancel = document.getElementById('btnCropCancel');
            const cropPresetButtons = document.getElementById('cropPresetButtons');
            const loadImageInput = document.getElementById('loadImageInput');
            const btnLoadTrigger = document.getElementById('btnLoadTrigger');
            const btnSave = document.getElementById('btnSave');
            const btnSaveAs = document.getElementById('btnSaveAs');
            const btnReset = document.getElementById('btnReset');
            const btnResize = document.getElementById('btnResize');
            const btnRotate = document.getElementById('btnRotate');
            const btnGrayscale = document.getElementById('btnGrayscale');
            const filterSelect = document.getElementById('filterSelect');
            const brightnessSlider = document.getElementById('brightnessSlider');
            const brightnessValueDisplay = document.getElementById('brightnessValue');
            const contrastSlider = document.getElementById('contrastSlider');
            const contrastValueDisplay = document.getElementById('contrastValue');
            const imageCanvas = document.getElementById('imageCanvas');
            const ctx = imageCanvas.getContext('2d');
            const noImageText = document.getElementById('noImageText');
            const statusText = document.getElementById('statusText');
            const themeToggle = document.getElementById('themeToggle');
            const languageSelector = document.getElementById('languageSelector');
            const resizeModal = document.getElementById('resizeModal');
            const currentSizeText = document.getElementById('currentSizeText');
            const newWidthInput = document.getElementById('newWidth');
            const newHeightInput = document.getElementById('newHeight');
            const btnResizeConfirm = document.getElementById('btnResizeConfirm');
            const btnResizeCancel = document.getElementById('btnResizeCancel');
            const resizePresetButtons = document.getElementById('resizePresetButtons');
            const rotateModal = document.getElementById('rotateModal');
            const rotationAngleInput = document.getElementById('rotationAngle');
            const btnRotateConfirm = document.getElementById('btnRotateConfirm');
            const btnRotateCancel = document.getElementById('btnRotateCancel');

            let originalImage = null, currentImageForOperations = null;
            let currentImageFileName = 'untitled.png';
            let currentWidth, currentHeight;
            const initialSettings = { brightness: 100, contrast: 100, filter: 'none', rotation: 0 };
            let currentSettings = { ...initialSettings };
            
            let isCropping = false;
            let cropRect = { x: 0, y: 0, width: 0, height: 0 };
            let cropDrag = { active: false, type: 'move', startX: 0, startY: 0 };
            let currentCropRatio = 'free';

            function getLang() { return translations[currentLanguage] || translations.en; }
            function alertError(message) { console.error(message); alert(`${getLang().errorPrefix}: ${message}`); }
            function alertInfo(message) { console.log(message); alert(message); }
            function updateStatus(message) { statusText.textContent = message; }
            
            function getDisplayedImageRect() {
                if (!currentImageForOperations) return null;
                const canvas = imageCanvas;
                const img = currentImageForOperations;
                
                const canvasAspect = canvas.clientWidth / canvas.clientHeight;
                const imgAspect = img.width / img.height;
                
                let dispWidth, dispHeight;
                if (imgAspect > canvasAspect) {
                    dispWidth = canvas.clientWidth;
                    dispHeight = dispWidth / imgAspect;
                } else {
                    dispHeight = canvas.clientHeight;
                    dispWidth = dispHeight * imgAspect;
                }
                
                const x = (canvas.clientWidth - dispWidth) / 2;
                const y = (canvas.clientHeight - dispHeight) / 2;
                
                return { x, y, width: dispWidth, height: dispHeight };
            }

            function setControlsState(enabled) {
                const buttonsToToggle = [btnSave, btnSaveAs, btnReset, btnResize, btnCrop, btnRotate, btnGrayscale];
                buttonsToToggle.forEach(btn => btn.disabled = !enabled);
                filterSelect.disabled = !enabled;
                brightnessSlider.disabled = !enabled;
                contrastSlider.disabled = !enabled;
            }

            function resetAdjustmentsToDefault() {
                const savedRotation = currentSettings.rotation;
                currentSettings = { ...initialSettings };
                currentSettings.rotation = savedRotation;
                brightnessSlider.value = currentSettings.brightness;
                brightnessValueDisplay.textContent = currentSettings.brightness;
                contrastSlider.value = currentSettings.contrast;
                contrastValueDisplay.textContent = currentSettings.contrast;
                filterSelect.value = currentSettings.filter;
            }
            
            function drawImageToCanvas() {
                if (isCropping) {
                    drawCropOverlay();
                    return;
                }
                if (!originalImage) return;

                noImageText.style.display = 'none';
                imageCanvas.style.display = 'block';

                const imageToDraw = currentImageForOperations || originalImage;
                
                const rad = currentSettings.rotation * Math.PI / 180;
                const absCos = Math.abs(Math.cos(rad));
                const absSin = Math.abs(Math.sin(rad));
                
                const newCanvasWidth = imageToDraw.width * absCos + imageToDraw.height * absSin;
                const newCanvasHeight = imageToDraw.width * absSin + imageToDraw.height * absCos;

                imageCanvas.width = newCanvasWidth;
                imageCanvas.height = newCanvasHeight;
                
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                
                let filterString = '';
                filterString += `brightness(${currentSettings.brightness}%) `;
                filterString += `contrast(${currentSettings.contrast}%) `;

                if (currentSettings.filter === 'blur' || currentSettings.filter === 'smooth') filterString += `blur(3px) `;
                else if (currentSettings.filter === 'grayscale') filterString += `grayscale(100%) `;
                
                ctx.filter = filterString.trim();

                ctx.translate(imageCanvas.width / 2, imageCanvas.height / 2);
                ctx.rotate(rad);
                ctx.drawImage(imageToDraw, -imageToDraw.width / 2, -imageToDraw.height / 2, imageToDraw.width, imageToDraw.height);
                
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.filter = 'none';

                updateStatus(getLang().statusImageInfo(currentImageFileName, imageToDraw.width, imageToDraw.height, currentSettings.rotation));
            }
            
            function enterCropMode() {
                if (!currentImageForOperations || currentSettings.rotation !== 0) {
                    if (currentSettings.rotation !== 0) alertInfo("Please reset rotation to 0 before cropping.");
                    return;
                }
                isCropping = true;
                mainControls.classList.add('hidden');
                croppingControlsPanel.classList.remove('hidden');
                imageCanvas.classList.add('is-cropping');
                
                const imgRect = getDisplayedImageRect();
                imageCanvas.width = imageCanvas.clientWidth;
                imageCanvas.height = imageCanvas.clientHeight;
                
                cropRect.width = imgRect.width * 0.8;
                cropRect.height = imgRect.height * 0.8;
                cropRect.x = imgRect.x + (imgRect.width - cropRect.width) / 2;
                cropRect.y = imgRect.y + (imgRect.height - cropRect.height) / 2;
                
                updateStatus(getLang().statusCropping);
                addCropListeners();
                drawCropOverlay();
            }

            function exitCropMode() {
                isCropping = false;
                mainControls.classList.remove('hidden');
                croppingControlsPanel.classList.add('hidden');
                imageCanvas.classList.remove('is-cropping');
                removeCropListeners();
                drawImageToCanvas();
            }
            
            function performCrop() {
                const dispRect = getDisplayedImageRect();
                const scale = currentImageForOperations.width / dispRect.width;

                const sourceX = (cropRect.x - dispRect.x) * scale;
                const sourceY = (cropRect.y - dispRect.y) * scale;
                const sourceWidth = cropRect.width * scale;
                const sourceHeight = cropRect.height * scale;
                
                if (sourceWidth < 1 || sourceHeight < 1) {
                    exitCropMode();
                    return;
                }
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = sourceWidth;
                tempCanvas.height = sourceHeight;
                tempCanvas.getContext('2d').drawImage(currentImageForOperations, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);
                
                const croppedImage = new Image();
                croppedImage.onload = () => {
                    currentImageForOperations = croppedImage;
                    currentWidth = croppedImage.width;
                    currentHeight = croppedImage.height;
                    exitCropMode();
                };
                croppedImage.src = tempCanvas.toDataURL();
            }

            function drawCropOverlay() {
                if (!isCropping || !currentImageForOperations) return;
                
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                
                const imgRect = getDisplayedImageRect();
                ctx.drawImage(currentImageForOperations, imgRect.x, imgRect.y, imgRect.width, imgRect.height);
                
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.rect(0, 0, imageCanvas.width, imageCanvas.height);
                ctx.rect(cropRect.x, cropRect.y, cropRect.width, cropRect.height);
                ctx.fill('evenodd');
                ctx.restore();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(cropRect.x, cropRect.y, cropRect.width, cropRect.height);
                
                const handleSize = 8;
                ctx.fillStyle = '#ffffff';
                getResizeHandles().forEach(h => {
                    ctx.fillRect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
                });
            }
            
            function getResizeHandles() {
                const { x, y, width, height } = cropRect;
                return [
                    { x: x, y: y, type: 'nw' }, { x: x + width/2, y: y, type: 'n' }, { x: x + width, y: y, type: 'ne' },
                    { x: x, y: y + height/2, type: 'w' }, { x: x + width, y: y + height/2, type: 'e' },
                    { x: x, y: y + height, type: 'sw' }, { x: x + width/2, y: y + height, type: 's' }, { x: x + width, y: y + height, type: 'se' }
                ];
            }

            function getHandleAtPos(x, y) {
                const handleSize = 12;
                for (const handle of getResizeHandles()) {
                    if (x >= handle.x - handleSize/2 && x <= handle.x + handleSize/2 && y >= handle.y - handleSize/2 && y <= handle.y + handleSize/2) {
                        return handle.type;
                    }
                }
                if (x > cropRect.x && x < cropRect.x + cropRect.width && y > cropRect.y && y < cropRect.y + cropRect.height) {
                    return 'move';
                }
                return null;
            }
            
            function handleCropMouseDown(e) {
                e.preventDefault();
                const { x, y } = getCanvasMousePos(e);
                const handle = getHandleAtPos(x, y);
                if (handle) {
                    cropDrag.active = true;
                    cropDrag.type = handle;
                    cropDrag.startX = x;
                    cropDrag.startY = y;
                    cropDrag.initialRect = { ...cropRect };
                }
            }

            function handleCropMouseMove(e) {
                e.preventDefault();
                const { x, y } = getCanvasMousePos(e);
                if (cropDrag.active) {
                    const dx = x - cropDrag.startX;
                    const dy = y - cropDrag.startY;
                    const i = cropDrag.initialRect;
                    let newX = i.x, newY = i.y, newW = i.width, newH = i.height;

                    if (cropDrag.type.includes('e')) newW += dx;
                    if (cropDrag.type.includes('w')) { newW -= dx; newX += dx; }
                    if (cropDrag.type.includes('s')) newH += dy;
                    if (cropDrag.type.includes('n')) { newH -= dy; newY += dy; }
                    if (cropDrag.type === 'move') { newX += dx; newY += dy; }

                    if (newW < 10) newW = 10;
                    if (newH < 10) newH = 10;

                    if (currentCropRatio !== 'free') {
                        const ratio = parseFloat(currentCropRatio);
                        if (/[ew]/.test(cropDrag.type)) newH = newW / ratio;
                        else if (/[ns]/.test(cropDrag.type)) newW = newH * ratio;
                    }
                    cropRect = { x: newX, y: newY, width: newW, height: newH };
                    drawCropOverlay();
                } else {
                    const handle = getHandleAtPos(x, y);
                    const cursorMap = { nw: 'nwse-resize', n: 'ns-resize', ne: 'nesw-resize', w: 'ew-resize', e: 'ew-resize', sw: 'nesw-resize', s: 'ns-resize', se: 'nwse-resize', move: 'move' };
                    imageCanvas.style.cursor = cursorMap[handle] || 'crosshair';
                }
            }

            function handleCropMouseUp(e) {
                cropDrag.active = false;
            }

            function getCanvasMousePos(e) {
                const rect = imageCanvas.getBoundingClientRect();
                const x = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const y = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                return { x: x - rect.left, y: y - rect.top };
            }
            
            function addCropListeners() {
                imageCanvas.addEventListener('mousedown', handleCropMouseDown);
                window.addEventListener('mousemove', handleCropMouseMove);
                window.addEventListener('mouseup', handleCropMouseUp);
                imageCanvas.addEventListener('touchstart', handleCropMouseDown, { passive: false });
                window.addEventListener('touchmove', handleCropMouseMove, { passive: false });
                window.addEventListener('touchend', handleCropMouseUp);
            }
            function removeCropListeners() {
                imageCanvas.removeEventListener('mousedown', handleCropMouseDown);
                window.removeEventListener('mousemove', handleCropMouseMove);
                window.removeEventListener('mouseup', handleCropMouseUp);
                imageCanvas.removeEventListener('touchstart', handleCropMouseDown);
                window.removeEventListener('touchmove', handleCropMouseMove);
                window.removeEventListener('touchend', handleCropMouseUp);
                imageCanvas.style.cursor = 'default';
            }
            
            function setCropRatio(ratio) {
                currentCropRatio = ratio;
                if (ratio === 'free') return;
                
                const numRatio = parseFloat(ratio);
                const { x, y, width, height } = cropRect;
                let newWidth = width, newHeight = height;
                
                if (width / height > numRatio) newWidth = height * numRatio;
                else newHeight = width / numRatio;
                
                cropRect.x += (width - newWidth) / 2;
                cropRect.y += (height - newHeight) / 2;
                cropRect.width = newWidth;
                cropRect.height = newHeight;
                
                drawCropOverlay();
            }

            btnLoadTrigger.addEventListener('click', () => loadImageInput.click());
            loadImageInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    currentImageFileName = file.name;
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        originalImage = new Image();
                        originalImage.onload = () => {
                            currentImageForOperations = originalImage;
                            currentWidth = originalImage.naturalWidth;
                            currentHeight = originalImage.naturalHeight;
                            currentSettings.rotation = 0;
                            resetAdjustmentsToDefault();
                            drawImageToCanvas();
                            setControlsState(true);
                        };
                        originalImage.onerror = () => { alertError(getLang().errorLoad); setControlsState(false); };
                        originalImage.src = e.target.result;
                    };
                    reader.onerror = () => { alertError(getLang().errorReadFile); setControlsState(false); };
                    reader.readAsDataURL(file);
                }
                loadImageInput.value = null;
            });
            
            function performSave(fileName) {
                if (!currentImageForOperations) {
                    alertInfo(getLang().alertNoImageToSave);
                    return;
                }
                drawImageToCanvas(); 
                
                const link = document.createElement('a');
                link.download = fileName || 'edited-image.png';
                
                const tempSaveCanvas = document.createElement('canvas');
                const tempSaveCtx = tempSaveCanvas.getContext('2d');
                tempSaveCanvas.width = imageCanvas.width;
                tempSaveCanvas.height = imageCanvas.height;
                const isJpg = fileName && (fileName.toLowerCase().endsWith('.jpg') || fileName.toLowerCase().endsWith('.jpeg'));
                if (isJpg) {
                    tempSaveCtx.fillStyle = 'white'; 
                    tempSaveCtx.fillRect(0, 0, tempSaveCanvas.width, tempSaveCanvas.height);
                }
                let filterString = '';
                filterString += `brightness(${currentSettings.brightness}%) `;
                filterString += `contrast(${currentSettings.contrast}%) `;
                if (currentSettings.filter === 'blur' || currentSettings.filter === 'smooth') filterString += `blur(3px) `;
                if (currentSettings.filter === 'grayscale') filterString += `grayscale(100%) `;
                tempSaveCtx.filter = filterString.trim();
                tempSaveCtx.translate(tempSaveCanvas.width / 2, tempSaveCanvas.height / 2);
                tempSaveCtx.rotate(currentSettings.rotation * Math.PI / 180);
                tempSaveCtx.drawImage(currentImageForOperations, -currentImageForOperations.width/2, -currentImageForOperations.height/2);
                link.href = isJpg ? tempSaveCanvas.toDataURL('image/jpeg', 0.95) : tempSaveCanvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                alertInfo(getLang().alertImageSaved(link.download));
            }
            btnSave.addEventListener('click', () => performSave(currentImageFileName));
            btnSaveAs.addEventListener('click', () => {
                const newFileName = prompt(getLang().promptSaveAs, currentImageFileName);
                if (newFileName) {
                    performSave(newFileName);
                    currentImageFileName = newFileName; 
                }
            });
            btnReset.addEventListener('click', () => {
                if (originalImage) {
                    currentImageForOperations = originalImage;
                    currentWidth = originalImage.naturalWidth;
                    currentHeight = originalImage.naturalHeight;
                    currentSettings.rotation = 0;
                    resetAdjustmentsToDefault();
                    drawImageToCanvas();
                    alertInfo(getLang().alertImageReset);
                }
            });
            btnResize.addEventListener('click', () => {
                if (!currentImageForOperations) return;
                currentSizeText.textContent = `${getLang().currentSize}: ${currentWidth}x${currentHeight}`;
                newWidthInput.value = currentWidth;
                newHeightInput.value = currentHeight;
                resizeModal.style.display = 'flex';
            });
            btnCrop.addEventListener('click', enterCropMode);
            btnCropConfirm.addEventListener('click', performCrop);
            btnCropCancel.addEventListener('click', exitCropMode);
            cropPresetButtons.addEventListener('click', (e) => {
                if(e.target.tagName === 'BUTTON') setCropRatio(e.target.dataset.ratio);
            });
            resizePresetButtons.addEventListener('click', (e) => {
                if (e.target.tagName !== 'BUTTON') return;
                const preset = e.target.dataset.preset;
                let w, h;
                if (preset.includes('%')) {
                    const factor = parseInt(preset) / 100;
                    w = Math.round(currentWidth * factor);
                    h = Math.round(currentHeight * factor);
                } else {
                    [w, h] = preset.split('x').map(Number);
                }
                newWidthInput.value = w;
                newHeightInput.value = h;
            });
            btnResizeConfirm.addEventListener('click', () => {
                const w = parseInt(newWidthInput.value);
                const h = parseInt(newHeightInput.value);
                if (w > 0 && h > 0) {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = w;
                    tempCanvas.height = h;
                    tempCanvas.getContext('2d').drawImage(currentImageForOperations, 0, 0, w, h);
                    const resizedImage = new Image();
                    resizedImage.onload = () => {
                        currentImageForOperations = resizedImage;
                        currentWidth = w;
                        currentHeight = h;
                        drawImageToCanvas();
                    };
                    resizedImage.onerror = () => alertError(getLang().errorResize);
                    resizedImage.src = tempCanvas.toDataURL();
                    resizeModal.style.display = 'none';
                } else {
                    alertError(getLang().errorResizeValues);
                }
            });
            btnResizeCancel.addEventListener('click', () => resizeModal.style.display = 'none');
            btnRotate.addEventListener('click', () => {
                if (!currentImageForOperations) return;
                rotationAngleInput.value = 90;
                rotateModal.style.display = 'flex';
            });
            btnRotateConfirm.addEventListener('click', () => {
                const angle = parseFloat(rotationAngleInput.value);
                if (!isNaN(angle)) {
                    currentSettings.rotation = (currentSettings.rotation + angle) % 360;
                    drawImageToCanvas(); 
                    rotateModal.style.display = 'none';
                } else {
                    alertError(getLang().errorInvalidAngle);
                }
            });
            btnRotateCancel.addEventListener('click', () => rotateModal.style.display = 'none');
            btnGrayscale.addEventListener('click', () => {
                if (!currentImageForOperations) return;
                if (currentSettings.filter === 'grayscale') {
                    currentSettings.filter = 'none';
                    if(filterSelect.value === 'grayscale') filterSelect.value = 'none';
                } else {
                    currentSettings.filter = 'grayscale';
                }
                drawImageToCanvas();
            });
            filterSelect.addEventListener('change', (event) => {
                currentSettings.filter = event.target.value;
                drawImageToCanvas();
            });
            brightnessSlider.addEventListener('input', (event) => {
                currentSettings.brightness = parseInt(event.target.value);
                brightnessValueDisplay.textContent = currentSettings.brightness;
                drawImageToCanvas();
            });
            contrastSlider.addEventListener('input', (event) => {
                currentSettings.contrast = parseInt(event.target.value);
                contrastValueDisplay.textContent = currentSettings.contrast;
                drawImageToCanvas();
            });
            
            function applyTheme(theme) {
                if (theme === 'dark') document.body.classList.add('dark-mode');
                else document.body.classList.remove('dark-mode');
            }
            themeToggle.addEventListener('click', () => {
                const newTheme = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
                applyTheme(newTheme);
                localStorage.setItem('theme', newTheme);
            });
            function initializeTheme() {
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme) {
                    applyTheme(savedTheme);
                } else {
                    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)');
                    applyTheme(systemPrefersDark.matches ? 'dark' : 'light');
                    systemPrefersDark.addEventListener('change', e => {
                        if (!localStorage.getItem('theme')) applyTheme(e.matches ? 'dark' : 'light');
                    });
                }
            }
            function applyTranslations(lang) {
                const supportedLangs = Object.keys(translations);
                if (!supportedLangs.includes(lang)) lang = 'en';
                currentLanguage = lang;
                languageSelector.value = lang;
                localStorage.setItem('language', lang);
                document.documentElement.lang = {en: "Image Editor", de: "Bildbearbeitung", es: "Editor de Imágenes"}[lang];
                document.querySelectorAll('[data-translate-key]').forEach(el => {
                    const key = el.getAttribute('data-translate-key');
                    const translation = getLang()[key] || translations.en[key];
                    if (translation && typeof translation === 'string') el.textContent = translation;
                });
            }
            function initializeLanguage() {
                Object.keys(translations).forEach(lang => {
                    const option = document.createElement('option');
                    option.value = lang;
                    option.textContent = translations[lang].langName;
                    languageSelector.appendChild(option);
                });
                const savedLang = localStorage.getItem('language');
                const browserLang = navigator.language.split('-')[0];
                const initialLang = savedLang || (Object.keys(translations).includes(browserLang) ? browserLang : 'en');
                applyTranslations(initialLang);
                languageSelector.addEventListener('change', (e) => {
                    applyTranslations(e.target.value);
                    if (originalImage) {
                        currentSizeText.textContent = `${getLang().currentSize}: ${currentWidth}x${currentHeight}`;
                        drawImageToCanvas();
                    } else {
                        updateStatus(getLang().statusLoadPrompt);
                    }
                });
            }
            
            initializeTheme();
            initializeLanguage();
            setControlsState(false);
            noImageText.style.display = 'block';
            imageCanvas.style.display = 'none';
            updateStatus(getLang().statusLoadPrompt);
        });
    </script>
</body>
</html>