<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Beginner's Guide to C++</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
        }
        #sidebar {
            width: 280px;
            background-color: #333;
            color: #fff;
            padding: 20px;
            height: 100vh;
            position: fixed;
            overflow-y: auto;
        }
        #sidebar h2 {
            color: #fff;
            text-align: center;
            margin-bottom: 20px;
        }
        #sidebar ul {
            list-style-type: none;
            padding: 0;
        }
        #sidebar ul li a {
            display: block;
            color: #ddd;
            padding: 10px 15px;
            text-decoration: none;
            border-radius: 4px;
            margin-bottom: 5px;
            transition: background-color 0.3s, color 0.3s;
        }
        #sidebar ul li a:hover, #sidebar ul li a.active {
            background-color: #5cb85c; /* Green for active */
            color: #fff;
        }
        #main-content {
            margin-left: 300px; /* Same as sidebar width + some padding */
            padding: 20px 40px;
            width: calc(100% - 300px);
            background-color: #fff;
            min-height: 100vh;
        }
        header {
            border-bottom: 1px solid #ddd;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        header h1 {
            color: #333;
            margin: 0;
        }
        section {
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        section:last-child {
            border-bottom: none;
        }
        h2 {
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-top: 0;
        }
        h3 {
            color: #17a2b8;
        }
        ul, ol {
            margin-bottom: 15px;
        }
        li {
            margin-bottom: 8px;
        }
        a {
            color: #007bff;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        code.inline-code {
            background-color: #e9ecef;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: "Courier New", Courier, monospace;
            color: #c7254e;
        }
        pre {
            background-color: #2d2d2d; /* Darker background for C++ code */
            color: #f8f8f2; /* Light text for contrast */
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "Consolas", "Courier New", Courier, monospace; /* Common coding fonts */
            font-size: 0.9em;
            border: 1px solid #444;
        }
        pre code {
            padding: 0;
            background-color: transparent;
            border-radius: 0;
            color: inherit; /* Inherit color from pre */
        }
        /* Basic C++ syntax highlighting (can be expanded) */
        pre code .cpp-keyword { color: #66d9ef; font-weight: bold; } /* Keywords */
        pre code .cpp-comment { color: #75715e; } /* Comments */
        pre code .cpp-string { color: #e6db74; } /* Strings */
        pre code .cpp-preprocessor { color: #f92672; } /* Preprocessor directives */
        pre code .cpp-number { color: #ae81ff; } /* Numbers */
        pre code .cpp-operator { color: #f92672; } /* Operators */
        pre code .cpp-type { color: #a6e22e; } /* Types */


        .warning, .important {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .warning {
            background-color: #fff3cd;
            border-left: 5px solid #ffeeba;
            color: #856404;
        }
        .important {
            background-color: #d1ecf1;
            border-left: 5px solid #bee5eb;
            color: #0c5460;
        }
        .path {
            font-style: italic;
            color: #555;
            background-color: #e9ecef;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: "Courier New", Courier, monospace;
        }
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            #sidebar {
                width: 100%;
                height: auto;
                position: relative;
                margin-bottom: 20px;
            }
            #main-content {
                margin-left: 0;
                width: 100%;
                padding: 20px;
            }
        }
    </style>
</head>
<body>

    <nav id="sidebar">
        <h2>C++ Guide</h2>
        <ul>
            <li><a href="#introduction">Introduction to C++</a></li>
            <li><a href="#setting-up">Setting Up Environment</a></li>
            <li><a href="#first-program">Your First C++ Program</a></li>
            <li><a href="#variables-datatypes">Variables & Data Types</a></li>
            <li><a href="#operators">Operators</a></li>
            <li><a href="#input-output">Input and Output</a></li>
            <li><a href="#control-flow">Control Flow</a></li>
            <li><a href="#functions">Functions</a></li>
            <li><a href="#arrays">Arrays</a></li>
            <li><a href="#strings">Strings</a></li>
            <li><a href="#pointers">Pointers</a></li>
            <li><a href="#oop-core">Object-Oriented Programming</a></li>
            <li><a href="#stl-intro">Intro to STL</a></li>
            <li><a href="#exception-handling">Exception Handling</a></li>
            <li><a href="#file-io-intro">Intro to File I/O</a></li>
            <li><a href="#next-steps">Next Steps</a></li>
        </ul>
    </nav>

    <div id="main-content">
        <header>
            <h1>A Comprehensive Beginner's Guide to C++</h1>
        </header>

        <section id="introduction">
            <h2>Introduction to C++</h2>
            <p>C++ is a powerful, general-purpose programming language. It was created by Bjarne Stroustrup as an extension of the C language, with the primary goal of adding object-oriented features. C++ is known for its performance, efficiency, and control over system hardware and memory management.</p>
            <p><strong>Key Features of C++:</strong></p>
            <ul>
                <li><strong>Object-Oriented:</strong> Supports core OOP principles like encapsulation, inheritance, and polymorphism.</li>
                <li><strong>High Performance:</strong> C++ code can be compiled directly into machine code, resulting in fast execution.</li>
                <li><strong>Memory Management:</strong> Provides low-level memory manipulation capabilities through pointers and manual memory allocation/deallocation.</li>
                <li><strong>Statically-Typed:</strong> Variable types are checked at compile-time, which helps catch errors early.</li>
                <li><strong>Portability:</strong> C++ compilers are available for a wide range of platforms.</li>
                <li><strong>Extensive Standard Library:</strong> Includes the Standard Template Library (STL) which provides common data structures and algorithms.</li>
                <li><strong>Middle-Level Language:</strong> Combines features of both high-level (abstraction, OOP) and low-level (direct memory access) languages.</li>
            </ul>
            <p>C++ is widely used in game development, operating systems, browsers, database software, high-performance computing, embedded systems, and financial applications.</p>
        </section>

        <section id="setting-up">
            <h2>Setting Up Your Environment</h2>
            <p>To write, compile, and run C++ programs, you need a C++ compiler and typically a text editor or an Integrated Development Environment (IDE).</p>
            <h3>1. C++ Compiler</h3>
            <p>A compiler translates your C++ source code into machine code that your computer can execute.</p>
            Common C++ compilers:
            <ul>
                <li><strong>GCC (GNU Compiler Collection):</strong> Includes g++, a popular open-source C++ compiler available on Linux, macOS (via Xcode Command Line Tools or Homebrew), and Windows (via MinGW or Cygwin).</li>
                <li><strong>Clang:</strong> A C/C++/Objective-C compiler front-end for LLVM. Known for fast compilation and good error messages. Available on many platforms.</li>
                <li><strong>MSVC (Microsoft Visual C++):</strong> Part of Visual Studio, primarily for Windows development.</li>
            </ul>
            <p><strong>Installation:</strong></p>
            <ul>
                <li><strong>Windows:</strong>
                    <ul>
                        <li>Install <a href="https://visualstudio.microsoft.com/vs/features/cplusplus/" target="_blank">Visual Studio Community Edition</a> (includes MSVC).</li>
                        <li>Alternatively, install MinGW-w64 (for GCC/g++) or use Windows Subsystem for Linux (WSL) to get a Linux environment with GCC.</li>
                    </ul>
                </li>
                <li><strong>macOS:</strong>
                    <ul>
                        <li>Install Xcode from the App Store, then open Terminal and run <code class="path">xcode-select --install</code> to install Command Line Tools (includes Clang).</li>
                        <li>Or, install GCC via Homebrew: <code class="path">brew install gcc</code>.</li>
                    </ul>
                </li>
                <li><strong>Linux (Debian/Ubuntu based):</strong> Open Terminal and run:
<pre><code class="path">sudo apt update
sudo apt install build-essential gdb
</code></pre>
                    This installs g++ and other essential development tools. For other distributions, use their respective package managers (e.g., <code class="path">dnf</code> for Fedora, <code class="path">pacman</code> for Arch).
                </li>
            </ul>
            <p>To verify your compiler installation, open a terminal and try (for g++):</p>
<pre><code class="path">g++ --version</code></pre>

            <h3>2. Integrated Development Environment (IDE) or Text Editor</h3>
            <ul>
                <li><strong>Visual Studio (Windows):</strong> A full-featured IDE for C++ development on Windows.</li>
                <li><strong>Visual Studio Code (Cross-platform):</strong> A lightweight but powerful source code editor with excellent C++ support via extensions (like "C/C++" from Microsoft).</li>
                <li><strong>CLion (Cross-platform):</strong> A powerful, paid C++ IDE from JetBrains (offers free licenses for students/educators).</li>
                <li><strong>Code::Blocks (Cross-platform):</strong> A free, open-source C++ IDE.</li>
                <li><strong>Eclipse CDT (Cross-platform):</strong> Eclipse IDE with C/C++ Development Tooling.</li>
                <li>Any plain text editor can also be used, but you'll need to compile from the command line.</li>
            </ul>
        </section>

        <section id="first-program">
            <h2>Your First C++ Program: "Hello, World!"</h2>
            <p>Let's create a simple program that prints "Hello, World!" to the console.</p>
            <ol>
                <li><strong>Create a file:</strong> Open your text editor or IDE and create a new file named <code class="inline-code">hello.cpp</code> (or any name ending with <code class="inline-code">.cpp</code>, <code class="inline-code">.cc</code>, or <code class="inline-code">.cxx</code>).</li>
                <li><strong>Write the code:</strong>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span> <span class="cpp-comment">// For input and output operations</span>

<span class="cpp-comment">// The main function is the entry point of any C++ program</span>
<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    <span class="cpp-comment">// Print "Hello, World!" to the console</span>
    std::cout &lt;&lt; <span class="cpp-string">"Hello, World!"</span> &lt;&lt; std::endl;

    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>; <span class="cpp-comment">// Indicate that the program ended successfully</span>
}
</code></pre>
                </li>
                <li><strong>Save the file.</strong></li>
                <li><strong>Compile and run from the terminal (using g++):</strong>
                    <ol>
                        <li>Open your terminal or command prompt.</li>
                        <li>Navigate to the directory where you saved <code class="inline-code">hello.cpp</code>.</li>
                        <li>Compile the code:
<pre><code class="path">g++ hello.cpp -o hello_program</code></pre>
                            This command compiles <code class="inline-code">hello.cpp</code> and creates an executable file named <code class="inline-code">hello_program</code> (or <code class="inline-code">hello_program.exe</code> on Windows). The <code class="inline-code">-o</code> flag specifies the output file name.
                        </li>
                        <li>Run the executable:
                            <ul>
                                <li>On Linux/macOS: <code class="path">./hello_program</code></li>
                                <li>On Windows: <code class="path">hello_program.exe</code> or just <code class="path">hello_program</code></li>
                            </ul>
                        </li>
                    </ol>
                    If using an IDE, it will typically have a "Run" button that handles compilation and execution for you.
                </li>
            </ol>
            <p>You should see the output:</p>
<pre><code>Hello, World!</code></pre>
            <p><strong>Explanation:</strong></p>
            <ul>
                <li><code class="inline-code">#include &lt;iostream&gt;</code>: This is a preprocessor directive that tells the compiler to include the <code class="inline-code">iostream</code> header file. This file contains declarations for input/output operations (like <code class="inline-code">std::cout</code>).</li>
                <li><code class="inline-code">int main() { ... }</code>: This is the main function where program execution begins.
                    <ul>
                        <li><code class="inline-code">int</code>: Indicates that the <code class="inline-code">main</code> function returns an integer value.</li>
                        <li>A return value of <code class="inline-code">0</code> typically means the program executed successfully. Non-zero values usually indicate an error.</li>
                    </ul>
                </li>
                <li><code class="inline-code">std::cout</code>: This is the standard output stream object, used to print text to the console. It's part of the <code class="inline-code">std</code> (standard) namespace.</li>
                <li><code class="inline-code">&lt;&lt;</code>: This is the stream insertion operator. It "inserts" the data that follows it into the output stream.</li>
                <li><code class="inline-code">"Hello, World!"</code>: This is a string literal.</li>
                <li><code class="inline-code">std::endl</code>: This is a manipulator that inserts a newline character and flushes the output buffer.</li>
                <li>Semicolons <code class="inline-code">;</code> terminate statements in C++.</li>
                <li>Curly braces <code class="inline-code">{}</code> define blocks of code.</li>
                <li><code class="inline-code">//</code> indicates a single-line comment. Multi-line comments are <code class="inline-code">/* ... */</code>.</li>
            </ul>
            <p class="important">The <code class="inline-code">std::</code> prefix indicates that <code class="inline-code">cout</code> and <code class="inline-code">endl</code> belong to the standard namespace. You can avoid typing <code class="inline-code">std::</code> repeatedly by using a <code class="inline-code">using namespace std;</code> directive after your includes, but this is often discouraged in larger projects to avoid name collisions.</p>
        </section>

        <section id="variables-datatypes">
            <h2>Variables and Data Types</h2>
            <p>Variables are named storage locations in memory. In C++, you must declare the type of a variable before using it.</p>

            <h3>Declaring and Initializing Variables</h3>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-preprocessor">#include &lt;string&gt;</span> <span class="cpp-comment">// For std::string</span>

<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    <span class="cpp-comment">// Declaration: type variableName;</span>
    <span class="cpp-comment">// Initialization: variableName = value;</span>
    <span class="cpp-comment">// Declaration and Initialization: type variableName = value;</span>

    <span class="cpp-type">int</span> age = <span class="cpp-number">30</span>;                <span class="cpp-comment">// Integer type</span>
    <span class="cpp-type">double</span> salary = <span class="cpp-number">50000.75</span>;     <span class="cpp-comment">// Double-precision floating-point</span>
    <span class="cpp-type">char</span> grade = <span class="cpp-string">'A'</span>;              <span class="cpp-comment">// Character type (single quotes)</span>
    <span class="cpp-type">bool</span> isEmployed = <span class="cpp-keyword">true</span>;       <span class="cpp-comment">// Boolean type (true or false)</span>
    std::string name = <span class="cpp-string">"John Doe"</span>; <span class="cpp-comment">// String type (from &lt;string&gt; header)</span>

    std::cout &lt;&lt; <span class="cpp-string">"Name: "</span> &lt;&lt; name &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="cpp-string">"Age: "</span> &lt;&lt; age &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="cpp-string">"Is Employed: "</span> &lt;&lt; isEmployed &lt;&lt; std::endl; <span class="cpp-comment">// Prints 1 for true, 0 for false by default</span>
    
    <span class="cpp-comment">// To print "true" or "false" for bool:</span>
    std::cout &lt;&lt; <span class="cpp-string">"Is Employed (text): "</span> &lt;&lt; std::boolalpha &lt;&lt; isEmployed &lt;&lt; std::endl;

    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}
</code></pre>

            <h3>Fundamental Data Types</h3>
            <ul>
                <li><strong>Integer Types:</strong>
                    <ul>
                        <li><code class="inline-code">short int</code> (or <code class="inline-code">short</code>): Typically 2 bytes.</li>
                        <li><code class="inline-code">int</code>: Typically 4 bytes (platform dependent). Most common integer type.</li>
                        <li><code class="inline-code">long int</code> (or <code class="inline-code">long</code>): Typically 4 or 8 bytes.</li>
                        <li><code class="inline-code">long long int</code> (or <code class="inline-code">long long</code>): C++11. Typically 8 bytes.</li>
                        <li>These can be <code class="inline-code">signed</code> (default, can hold positive/negative) or <code class="inline-code">unsigned</code> (can hold only non-negative values, effectively doubling the positive range).</li>
                    </ul>
                </li>
                <li><strong>Character Type:</strong>
                    <ul>
                        <li><code class="inline-code">char</code>: Typically 1 byte. Used to store single characters. Can also be <code class="inline-code">signed</code> or <code class="inline-code">unsigned</code>.</li>
                        <li><code class="inline-code">wchar_t</code>: For wide characters (e.g., Unicode).</li>
                    </ul>
                </li>
                <li><strong>Floating-Point Types:</strong>
                    <ul>
                        <li><code class="inline-code">float</code>: Single-precision floating-point. Typically 4 bytes.
                            <pre><code class="language-cpp"><span class="cpp-type">float</span> price = <span class="cpp-number">19.99f</span>; <span class="cpp-comment">// 'f' suffix is important</span></code></pre>
                        </li>
                        <li><code class="inline-code">double</code>: Double-precision floating-point. Typically 8 bytes. (Default for decimal literals).</li>
                        <li><code class="inline-code">long double</code>: Extended-precision floating-point. Size varies.</li>
                    </ul>
                </li>
                <li><strong>Boolean Type:</strong>
                    <ul>
                        <li><code class="inline-code">bool</code>: Can hold <code class="inline-code">true</code> or <code class="inline-code">false</code>.</li>
                    </ul>
                </li>
                 <li><strong>Void Type:</strong>
                    <ul>
                        <li><code class="inline-code">void</code>: Represents the absence of type. Used for functions that do not return a value or for generic pointers.</li>
                    </ul>
                </li>
            </ul>

            <h3>Constants</h3>
            <p>Variables whose values cannot be changed after initialization.</p>
            <ul>
                <li>Using the <code class="inline-code">const</code> keyword:
<pre><code class="language-cpp"><span class="cpp-keyword">const</span> <span class="cpp-type">double</span> PI = <span class="cpp-number">3.14159</span>;
<span class="cpp-comment">// PI = 3.14; // Error: assignment of read-only variable 'PI'</span></code></pre>
                </li>
                <li>Using <code class="inline-code">#define</code> (preprocessor directive - generally less preferred for constants than <code class="inline-code">const</code> in modern C++):
<pre><code class="language-cpp"><span class="cpp-preprocessor">#define MAX_USERS 100</span></code></pre>
                </li>
            </ul>

            <h3>Type Casting</h3>
            <p>Converting a value from one data type to another.</p>
            <ul>
                <li><strong>Implicit Conversion (Coercion):</strong> Done automatically by the compiler when safe (e.g., <code class="inline-code">int</code> to <code class="inline-code">double</code>).
<pre><code class="language-cpp"><span class="cpp-type">int</span> num_int = <span class="cpp-number">10</span>;
<span class="cpp-type">double</span> num_double = num_int; <span class="cpp-comment">// num_double becomes 10.0</span></code></pre>
                </li>
                <li><strong>Explicit Conversion (Casting):</strong>
                    <ul>
                        <li><strong>C-style cast:</strong> <code class="inline-code">(new_type)expression</code>
<pre><code class="language-cpp"><span class="cpp-type">double</span> val_double = <span class="cpp-number">3.14</span>;
<span class="cpp-type">int</span> val_int = (<span class="cpp-type">int</span>)val_double; <span class="cpp-comment">// val_int becomes 3</span></code></pre>
                        </li>
                        <li><strong>C++ style casts (safer and more specific):</strong>
                            <ul>
                                <li><code class="inline-code">static_cast&lt;new_type&gt;(expression)</code>: For most common conversions (e.g., numeric types, pointers up/down hierarchy with care).
<pre><code class="language-cpp"><span class="cpp-type">int</span> x = <span class="cpp-number">10</span>;
<span class="cpp-type">double</span> y = <span class="cpp-keyword">static_cast</span>&lt;<span class="cpp-type">double</span>&gt;(x) / <span class="cpp-number">3</span>; <span class="cpp-comment">// y becomes 3.333...</span></code></pre>
                                </li>
                                <li><code class="inline-code">dynamic_cast</code> (for polymorphic types, covered later)</li>
                                <li><code class="inline-code">const_cast</code> (to add/remove const-ness, use with extreme caution)</li>
                                <li><code class="inline-code">reinterpret_cast</code> (for low-level, unsafe type conversions)</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
            <p class="important">C++ style casts are generally preferred over C-style casts in modern C++ code as they are more explicit and safer.</p>
        </section>

        <section id="operators">
            <h2>Operators</h2>
            <p>Operators perform operations on variables and values (operands).</p>
            <h3>1. Arithmetic Operators</h3>
            <ul>
                <li><code class="inline-code">+</code> (Addition), <code class="inline-code">-</code> (Subtraction), <code class="inline-code">*</code> (Multiplication), <code class="inline-code">/</code> (Division), <code class="inline-code">%</code> (Modulus)</li>
                <li><code class="inline-code">++</code> (Increment), <code class="inline-code">--</code> (Decrement) - can be prefix (<code class="inline-code">++x</code>) or postfix (<code class="inline-code">x++</code>).</li>
            </ul>
<pre><code class="language-cpp"><span class="cpp-type">int</span> a = <span class="cpp-number">10</span>, b = <span class="cpp-number">3</span>;
std::cout &lt;&lt; <span class="cpp-string">"a + b = "</span> &lt;&lt; (a + b) &lt;&lt; std::endl; <span class="cpp-comment">// 13</span>
std::cout &lt;&lt; <span class="cpp-string">"a / b = "</span> &lt;&lt; (a / b) &lt;&lt; std::endl; <span class="cpp-comment">// 3 (integer division)</span>
<span class="cpp-type">double</span> result_div = <span class="cpp-keyword">static_cast</span>&lt;<span class="cpp-type">double</span>&gt;(a) / b;
std::cout &lt;&lt; <span class="cpp-string">"a / b (double) = "</span> &lt;&lt; result_div &lt;&lt; std::endl; <span class="cpp-comment">// 3.333...</span>

<span class="cpp-type">int</span> c = <span class="cpp-number">5</span>;
c<span class="cpp-operator">++</span>; <span class="cpp-comment">// c becomes 6</span>
std::cout &lt;&lt; <span class="cpp-string">"c = "</span> &lt;&lt; c &lt;&lt; std::endl;
</code></pre>
            <h3>2. Relational (Comparison) Operators</h3>
            <p>Return <code class="inline-code">true</code> or <code class="inline-code">false</code>.</p>
            <ul>
                <li><code class="inline-code">==</code> (Equal to), <code class="inline-code">!=</code> (Not equal to), <code class="inline-code">></code> (Greater than), <code class="inline-code"><</code> (Less than), <code class="inline-code">>=</code> (Greater than or equal to), <code class="inline-code"><=</code> (Less than or equal to)</li>
            </ul>
            <h3>3. Logical Operators</h3>
            <ul>
                <li><code class="inline-code">&&</code> (Logical AND), <code class="inline-code">||</code> (Logical OR), <code class="inline-code">!</code> (Logical NOT)</li>
            </ul>
            <h3>4. Assignment Operators</h3>
            <ul>
                <li><code class="inline-code">=</code>, <code class="inline-code">+=</code>, <code class="inline-code">-=</code>, <code class="inline-code">*=</code>, <code class="inline-code">/=</code>, <code class="inline-code">%=</code>, etc.</li>
            </ul>
            <h3>5. Bitwise Operators (Brief)</h3>
            <p>Operate on individual bits of data.</p>
            <ul>
                <li><code class="inline-code">&</code> (Bitwise AND), <code class="inline-code">|</code> (Bitwise OR), <code class="inline-code">^</code> (Bitwise XOR), <code class="inline-code">~</code> (Bitwise NOT), <code class="inline-code">&lt;&lt;</code> (Left shift), <code class="inline-code">>></code> (Right shift)</li>
            </ul>
            <h3>6. Ternary Operator (Conditional Operator)</h3>
            <p><code class="inline-code">condition ? expression1 : expression2;</code></p>
<pre><code class="language-cpp"><span class="cpp-type">int</span> time = <span class="cpp-number">20</span>;
std::string greeting = (time &lt; <span class="cpp-number">18</span>) <span class="cpp-operator">?</span> <span class="cpp-string">"Good day."</span> <span class="cpp-operator">:</span> <span class="cpp-string">"Good evening."</span>;
std::cout &lt;&lt; greeting &lt;&lt; std::endl; <span class="cpp-comment">// Good evening.</span>
</code></pre>
        </section>

        <section id="input-output">
            <h2>Input and Output</h2>
            <p>C++ uses streams for input and output, primarily from the <code class="inline-code">&lt;iostream&gt;</code> library.</p>
            <h3>Standard Output (<code class="inline-code">std::cout</code>)</h3>
            <p>Used to print data to the console.</p>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-preprocessor">#include &lt;string&gt;</span>

<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    std::string name = <span class="cpp-string">"Alice"</span>;
    <span class="cpp-type">int</span> age = <span class="cpp-number">25</span>;

    std::cout &lt;&lt; <span class="cpp-string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="cpp-string">"!"</span> &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="cpp-string">"You are "</span> &lt;&lt; age &lt;&lt; <span class="cpp-string">" years old."</span> &lt;&lt; std::endl;
    
    std::cout &lt;&lt; <span class="cpp-string">"This "</span> &lt;&lt; <span class="cpp-string">"is "</span> &lt;&lt; <span class="cpp-string">"on "</span> &lt;&lt; <span class="cpp-string">"one "</span> &lt;&lt; <span class="cpp-string">"line."</span>;
    std::cout &lt;&lt; <span class="cpp-string">" This starts a new line."</span> &lt;&lt; std::endl;

    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}
</code></pre>

            <h3>Standard Input (<code class="inline-code">std::cin</code>)</h3>
            <p>Used to read data from the console (user input).</p>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-preprocessor">#include &lt;string&gt;</span>

<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    <span class="cpp-type">int</span> userAge;
    std::string userName;

    std::cout &lt;&lt; <span class="cpp-string">"Enter your name: "</span>;
    <span class="cpp-comment">// std::cin &gt;&gt; userName; // Reads only up to the first whitespace</span>
    std::getline(std::cin, userName); <span class="cpp-comment">// Reads the whole line, including spaces</span>
    
    std::cout &lt;&lt; <span class="cpp-string">"Enter your age: "</span>;
    std::cin &gt;&gt; userAge;

    std::cout &lt;&lt; <span class="cpp-string">"\nHello, "</span> &lt;&lt; userName &lt;&lt; <span class="cpp-string">"!"</span> &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="cpp-string">"You are "</span> &lt;&lt; userAge &lt;&lt; <span class="cpp-string">" years old."</span> &lt;&lt; std::endl;

    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}
</code></pre>
            <p class="warning"><code class="inline-code">std::cin</code> with the <code class="inline-code">>></code> operator stops reading at whitespace. To read a full line of text (including spaces), use <code class="inline-code">std::getline(std::cin, yourStringVariable);</code>. Be careful when mixing <code class="inline-code">std::cin >> var;</code> and <code class="inline-code">std::getline()</code>, as the newline character left by <code class="inline-code">std::cin >> var;</code> might be consumed by the subsequent <code class="inline-code">std::getline()</code>. You might need <code class="inline-code">std::cin.ignore()</code> to clear the buffer.</p>
        </section>

        <section id="control-flow">
            <h2>Control Flow</h2>
            <p>Control flow statements alter the normal sequential execution of statements.</p>
            <h3>1. Conditional Statements</h3>
            <h4>a) <code class="inline-code">if, else if, else</code></h4>
<pre><code class="language-cpp"><span class="cpp-type">int</span> score = <span class="cpp-number">85</span>;
<span class="cpp-keyword">if</span> (score &gt;<span class="cpp-operator">=</span> <span class="cpp-number">90</span>) {
    std::cout &lt;&lt; <span class="cpp-string">"Grade: A"</span> &lt;&lt; std::endl;
} <span class="cpp-keyword">else</span> <span class="cpp-keyword">if</span> (score &gt;<span class="cpp-operator">=</span> <span class="cpp-number">80</span>) {
    std::cout &lt;&lt; <span class="cpp-string">"Grade: B"</span> &lt;&lt; std::endl; <span class="cpp-comment">// This will be printed</span>
} <span class="cpp-keyword">else</span> {
    std::cout &lt;&lt; <span class="cpp-string">"Grade: C or lower"</span> &lt;&lt; std::endl;
}
</code></pre>
            <h4>b) <code class="inline-code">switch</code> statement</h4>
<pre><code class="language-cpp"><span class="cpp-type">char</span> option = <span class="cpp-string">'B'</span>;
<span class="cpp-keyword">switch</span> (option) {
    <span class="cpp-keyword">case</span> <span class="cpp-string">'A'</span>:
        std::cout &lt;&lt; <span class="cpp-string">"Selected Option A"</span> &lt;&lt; std::endl;
        <span class="cpp-keyword">break</span>;
    <span class="cpp-keyword">case</span> <span class="cpp-string">'B'</span>:
        std::cout &lt;&lt; <span class="cpp-string">"Selected Option B"</span> &lt;&lt; std::endl; <span class="cpp-comment">// This will be printed</span>
        <span class="cpp-keyword">break</span>;
    <span class="cpp-keyword">default</span>:
        std::cout &lt;&lt; <span class="cpp-string">"Invalid Option"</span> &lt;&lt; std::endl;
        <span class="cpp-keyword">break</span>;
}
</code></pre>
            <p class="important">Remember <code class="inline-code">break</code> statements in <code class="inline-code">switch</code> cases to prevent "fall-through".</p>

            <h3>2. Looping Statements</h3>
            <h4>a) <code class="inline-code">for</code> loop</h4>
<pre><code class="language-cpp"><span class="cpp-comment">// Traditional for loop</span>
<span class="cpp-keyword">for</span> (<span class="cpp-type">int</span> i = <span class="cpp-number">0</span>; i &lt; <span class="cpp-number">5</span>; i<span class="cpp-operator">++</span>) {
    std::cout &lt;&lt; <span class="cpp-string">"Iteration: "</span> &lt;&lt; i &lt;&lt; std::endl;
}

<span class="cpp-comment">// Range-based for loop (C++11 and later) - for iterating over collections</span>
<span class="cpp-type">int</span> numbers[] = {<span class="cpp-number">10</span>, <span class="cpp-number">20</span>, <span class="cpp-number">30</span>};
<span class="cpp-keyword">for</span> (<span class="cpp-type">int</span> num : numbers) {
    std::cout &lt;&lt; <span class="cpp-string">"Number: "</span> &lt;&lt; num &lt;&lt; std::endl;
}
</code></pre>
            <h4>b) <code class="inline-code">while</code> loop</h4>
<pre><code class="language-cpp"><span class="cpp-type">int</span> count = <span class="cpp-number">0</span>;
<span class="cpp-keyword">while</span> (count &lt; <span class="cpp-number">3</span>) {
    std::cout &lt;&lt; <span class="cpp-string">"While count: "</span> &lt;&lt; count &lt;&lt; std::endl;
    count<span class="cpp-operator">++</span>;
}
</code></pre>
            <h4>c) <code class="inline-code">do-while</code> loop</h4>
<pre><code class="language-cpp"><span class="cpp-type">int</span> i = <span class="cpp-number">5</span>;
<span class="cpp-keyword">do</span> {
    std::cout &lt;&lt; <span class="cpp-string">"Do-while i: "</span> &lt;&lt; i &lt;&lt; std::endl; <span class="cpp-comment">// Executes at least once</span>
    i<span class="cpp-operator">++</span>;
} <span class="cpp-keyword">while</span> (i &lt; <span class="cpp-number">5</span>);
</code></pre>

            <h3>3. Loop Control Statements</h3>
            <ul>
                <li><code class="inline-code">break</code>: Exits the current loop.</li>
                <li><code class="inline-code">continue</code>: Skips the rest of the current iteration and proceeds to the next.</li>
            </ul>
        </section>

        <section id="functions">
            <h2>Functions</h2>
            <p>A function is a block of code that performs a specific task. It can be called multiple times.</p>
            <h3>Declaration, Definition, and Calling</h3>
            <p>A function must be declared before it is called. The declaration (prototype) tells the compiler about the function's name, return type, and parameters. The definition contains the actual code.</p>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-preprocessor">#include &lt;string&gt;</span>

<span class="cpp-comment">// Function declaration (prototype)</span>
<span class="cpp-type">void</span> <span class="cpp-function">greetUser</span>(std::string name); 
<span class="cpp-type">int</span> <span class="cpp-function">addNumbers</span>(<span class="cpp-type">int</span> a, <span class="cpp-type">int</span> b);

<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    greetUser(<span class="cpp-string">"Alice"</span>); <span class="cpp-comment">// Calling the function</span>
    
    <span class="cpp-type">int</span> sum = addNumbers(<span class="cpp-number">5</span>, <span class="cpp-number">7</span>);
    std::cout &lt;&lt; <span class="cpp-string">"Sum is: "</span> &lt;&lt; sum &lt;&lt; std::endl;

    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}

<span class="cpp-comment">// Function definition for greetUser</span>
<span class="cpp-type">void</span> <span class="cpp-function">greetUser</span>(std::string name) {
    std::cout &lt;&lt; <span class="cpp-string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="cpp-string">"!"</span> &lt;&lt; std::endl;
}

<span class="cpp-comment">// Function definition for addNumbers</span>
<span class="cpp-type">int</span> <span class="cpp-function">addNumbers</span>(<span class="cpp-type">int</span> a, <span class="cpp-type">int</span> b) {
    <span class="cpp-keyword">return</span> a + b;
}
</code></pre>
            <p>Alternatively, you can define the function before <code class="inline-code">main()</code>, in which case a separate declaration is not needed if it's in the same file.</p>

            <h3>Parameters and Arguments</h3>
            <ul>
                <li><strong>Pass-by-Value:</strong> A copy of the argument's value is passed to the function. Changes to the parameter inside the function do not affect the original argument. (Default for fundamental types).</li>
                <li><strong>Pass-by-Reference:</strong> An alias (reference) to the original argument is passed. Changes to the parameter inside the function DO affect the original argument. Use an ampersand (<code class="inline-code">&</code>) in the parameter type.
<pre><code class="language-cpp"><span class="cpp-type">void</span> <span class="cpp-function">incrementByReference</span>(<span class="cpp-type">int</span><span class="cpp-operator">&amp;</span> num) {
    num<span class="cpp-operator">++</span>;
}
<span class="cpp-comment">// ... in main:</span>
<span class="cpp-type">int</span> val = <span class="cpp-number">10</span>;
incrementByReference(val); <span class="cpp-comment">// val becomes 11</span>
</code></pre>
                </li>
                <li><strong>Pass-by-Pointer:</strong> A pointer to the original argument is passed. Similar to pass-by-reference in effect but uses pointer syntax. (Covered more with Pointers).</li>
            </ul>

            <h3>Return Values</h3>
            <p>A function can return a single value using the <code class="inline-code">return</code> statement. The type of the returned value must match the function's declared return type. If a function doesn't return a value, its return type is <code class="inline-code">void</code>.</p>

            <h3>Function Overloading</h3>
            <p>Multiple functions can have the same name but different parameter lists (different number, type, or order of parameters).</p>
<pre><code class="language-cpp"><span class="cpp-type">int</span> <span class="cpp-function">printData</span>(<span class="cpp-type">int</span> i) { std::cout &lt;&lt; <span class="cpp-string">"Integer: "</span> &lt;&lt; i &lt;&lt; std::endl; <span class="cpp-keyword">return</span> i;}
<span class="cpp-type">double</span> <span class="cpp-function">printData</span>(<span class="cpp-type">double</span> f) { std::cout &lt;&lt; <span class="cpp-string">"Double: "</span> &lt;&lt; f &lt;&lt; std::endl; <span class="cpp-keyword">return</span> f;}
std::string <span class="cpp-function">printData</span>(std::string s) { std::cout &lt;&lt; <span class="cpp-string">"String: "</span> &lt;&lt; s &lt;&lt; std::endl; <span class="cpp-keyword">return</span> s;}
</code></pre>

            <h3>Default Arguments</h3>
            <p>You can provide default values for function parameters. If an argument is not provided when calling the function, the default value is used.</p>
<pre><code class="language-cpp"><span class="cpp-type">void</span> <span class="cpp-function">showValue</span>(<span class="cpp-type">int</span> val = <span class="cpp-number">100</span>) {
    std::cout &lt;&lt; <span class="cpp-string">"Value: "</span> &lt;&lt; val &lt;&lt; std::endl;
}
<span class="cpp-comment">// ... in main:</span>
showValue();      <span class="cpp-comment">// Prints Value: 100</span>
showValue(<span class="cpp-number">50</span>);    <span class="cpp-comment">// Prints Value: 50</span>
</code></pre>
        </section>

        <section id="arrays">
            <h2>Arrays</h2>
            <p>Arrays store a fixed-size sequential collection of elements of the same type.</p>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span>

<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    <span class="cpp-comment">// Declaration and initialization</span>
    <span class="cpp-type">int</span> numbers[<span class="cpp-number">5</span>]; <span class="cpp-comment">// Declares an array of 5 integers (uninitialized)</span>
    
    numbers[<span class="cpp-number">0</span>] = <span class="cpp-number">10</span>;
    numbers[<span class="cpp-number">1</span>] = <span class="cpp-number">20</span>;
    <span class="cpp-comment">// ... and so on for numbers[2], numbers[3], numbers[4]</span>

    <span class="cpp-type">double</span> prices[] = {<span class="cpp-number">19.99</span>, <span class="cpp-number">25.50</span>, <span class="cpp-number">9.75</span>}; <span class="cpp-comment">// Size inferred from initializer list (3)</span>

    <span class="cpp-comment">// Accessing elements (0-indexed)</span>
    std::cout &lt;&lt; <span class="cpp-string">"First number: "</span> &lt;&lt; numbers[<span class="cpp-number">0</span>] &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="cpp-string">"Second price: "</span> &lt;&lt; prices[<span class="cpp-number">1</span>] &lt;&lt; std::endl;

    <span class="cpp-comment">// Looping through an array</span>
    <span class="cpp-keyword">for</span> (<span class="cpp-type">int</span> i = <span class="cpp-number">0</span>; i &lt; <span class="cpp-number">3</span>; i<span class="cpp-operator">++</span>) { <span class="cpp-comment">// Be careful with array bounds!</span>
        std::cout &lt;&lt; <span class="cpp-string">"Price "</span> &lt;&lt; i &lt;&lt; <span class="cpp-string">": "</span> &lt;&lt; prices[i] &lt;&lt; std::endl;
    }
    
    <span class="cpp-comment">// Using sizeof to get array length (works for statically sized arrays)</span>
    <span class="cpp-type">int</span> numElements = <span class="cpp-keyword">sizeof</span>(prices) / <span class="cpp-keyword">sizeof</span>(prices[<span class="cpp-number">0</span>]);
    std::cout &lt;&lt; <span class="cpp-string">"Number of prices: "</span> &lt;&lt; numElements &lt;&lt; std::endl;


    <span class="cpp-comment">// Multi-dimensional array</span>
    <span class="cpp-type">int</span> matrix[<span class="cpp-number">2</span>][<span class="cpp-number">3</span>] = {
        {<span class="cpp-number">1</span>, <span class="cpp-number">2</span>, <span class="cpp-number">3</span>},
        {<span class="cpp-number">4</span>, <span class="cpp-number">5</span>, <span class="cpp-number">6</span>}
    };
    std::cout &lt;&lt; <span class="cpp-string">"Matrix[1][1]: "</span> &lt;&lt; matrix[<span class="cpp-number">1</span>][<span class="cpp-number">1</span>] &lt;&lt; std::endl; <span class="cpp-comment">// Output: 5</span>

    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}
</code></pre>
            <p class="warning">C-style arrays have no built-in bounds checking. Accessing an array out of bounds leads to undefined behavior. For more robust and flexible arrays, use <code class="inline-code">std::vector</code> or <code class="inline-code">std::array</code> from the STL.</p>
        </section>

        <section id="strings">
            <h2>Strings</h2>
            <p>C++ supports two main types of strings:</p>
            <h3>1. C-style Strings (Character Arrays)</h3>
            <p>A sequence of characters terminated by a null character (<code class="inline-code">'\0'</code>).</p>
<pre><code class="language-cpp"><span class="cpp-type">char</span> greeting[] = <span class="cpp-string">"Hello"</span>; <span class="cpp-comment">// Compiler adds '\0' automatically</span>
<span class="cpp-comment">// Is equivalent to: char greeting[] = {'H', 'e', 'l', 'l', 'o', '\0'};</span>
std::cout &lt;&lt; greeting &lt;&lt; std::endl;
</code></pre>
            <p>Manipulating C-style strings often involves functions from the <code class="inline-code">&lt;cstring&gt;</code> (or <code class="inline-code">&lt;string.h&gt;</code>) library (e.g., <code class="inline-code">strcpy</code>, <code class="inline-code">strlen</code>). They are prone to buffer overflows if not handled carefully.</p>

            <h3>2. <code class="inline-code">std::string</code> (C++ Standard Library Strings)</h3>
            <p>This is the preferred way to handle strings in modern C++. It's a class from the <code class="inline-code">&lt;string&gt;</code> header, providing dynamic sizing and many useful member functions.</p>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-preprocessor">#include &lt;string&gt;</span>

<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    std::string s1 = <span class="cpp-string">"Hello"</span>;
    std::string s2 = <span class="cpp-string">"World"</span>;
    std::string s3; <span class="cpp-comment">// Empty string</span>

    <span class="cpp-comment">// Concatenation</span>
    s3 = s1 + <span class="cpp-string">" "</span> + s2 + <span class="cpp-string">"!"</span>;
    std::cout &lt;&lt; <span class="cpp-string">"s3: "</span> &lt;&lt; s3 &lt;&lt; std::endl; <span class="cpp-comment">// Output: s3: Hello World!</span>

    <span class="cpp-comment">// Length</span>
    std::cout &lt;&lt; <span class="cpp-string">"Length of s3: "</span> &lt;&lt; s3.length() &lt;&lt; std::endl; <span class="cpp-comment">// or s3.size()</span>

    <span class="cpp-comment">// Accessing characters</span>
    std::cout &lt;&lt; <span class="cpp-string">"First char of s1: "</span> &lt;&lt; s1[<span class="cpp-number">0</span>] &lt;&lt; std::endl; <span class="cpp-comment">// Output: H</span>
    s1[<span class="cpp-number">0</span>] = <span class="cpp-string">'J'</span>;
    std::cout &lt;&lt; <span class="cpp-string">"Modified s1: "</span> &lt;&lt; s1 &lt;&lt; std::endl; <span class="cpp-comment">// Output: Jello</span>
    
    <span class="cpp-comment">// Comparison</span>
    <span class="cpp-keyword">if</span> (s1 == <span class="cpp-string">"Jello"</span>) {
        std::cout &lt;&lt; <span class="cpp-string">"s1 is Jello"</span> &lt;&lt; std::endl;
    }

    <span class="cpp-comment">// Substring</span>
    std::string sub = s3.substr(<span class="cpp-number">6</span>, <span class="cpp-number">5</span>); <span class="cpp-comment">// Start at index 6, length 5</span>
    std::cout &lt;&lt; <span class="cpp-string">"Substring: "</span> &lt;&lt; sub &lt;&lt; std::endl; <span class="cpp-comment">// Output: World</span>

    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}
</code></pre>
        </section>

        <section id="pointers">
            <h2>Pointers</h2>
            <p>A pointer is a variable that stores the memory address of another variable. Pointers allow for direct memory manipulation, dynamic memory allocation, and are fundamental to many C++ features.</p>
            <h3>Declaration and Initialization</h3>
            <ul>
                <li>Declaration: <code class="inline-code">type *pointer_name;</code></li>
                <li>Address-of operator (<code class="inline-code">&</code>): Gets the memory address of a variable.</li>
                <li>Dereference operator (<code class="inline-code">*</code>): Accesses the value stored at the address pointed to by the pointer.</li>
            </ul>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span>

<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    <span class="cpp-type">int</span> var = <span class="cpp-number">20</span>;
    <span class="cpp-type">int</span> <span class="cpp-operator">*</span>ptr;      <span class="cpp-comment">// Declare an integer pointer</span>

    ptr = <span class="cpp-operator">&amp;</span>var;   <span class="cpp-comment">// Store the address of var in ptr</span>

    std::cout &lt;&lt; <span class="cpp-string">"Value of var: "</span> &lt;&lt; var &lt;&lt; std::endl;         <span class="cpp-comment">// Output: 20</span>
    std::cout &lt;&lt; <span class="cpp-string">"Address of var (&amp;var): "</span> &lt;&lt; <span class="cpp-operator">&amp;</span>var &lt;&lt; std::endl; <span class="cpp-comment">// Outputs memory address</span>
    std::cout &lt;&lt; <span class="cpp-string">"Value of ptr (address it holds): "</span> &lt;&lt; ptr &lt;&lt; std::endl; <span class="cpp-comment">// Outputs same memory address</span>
    std::cout &lt;&lt; <span class="cpp-string">"Value pointed to by ptr (*ptr): "</span> &lt;&lt; <span class="cpp-operator">*</span>ptr &lt;&lt; std::endl; <span class="cpp-comment">// Output: 20</span>

    <span class="cpp-comment">// Modify var using the pointer</span>
    <span class="cpp-operator">*</span>ptr = <span class="cpp-number">30</span>;
    std::cout &lt;&lt; <span class="cpp-string">"New value of var: "</span> &lt;&lt; var &lt;&lt; std::endl; <span class="cpp-comment">// Output: 30</span>

    <span class="cpp-comment">// Null pointer (points to nothing)</span>
    <span class="cpp-type">int</span> <span class="cpp-operator">*</span>nullPtr = <span class="cpp-keyword">nullptr</span>; <span class="cpp-comment">// C++11 standard for null pointer (or NULL from &lt;cstddef&gt;)</span>
    <span class="cpp-comment">// if (nullPtr) { ... } // Check if pointer is not null before dereferencing</span>

    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}
</code></pre>
            <h3>Dynamic Memory Allocation (<code class="inline-code">new</code> and <code class="inline-code">delete</code>)</h3>
            <p>Allows allocating memory on the heap at runtime.</p>
            <ul>
                <li><code class="inline-code">new</code>: Allocates memory and returns a pointer to it.</li>
                <li><code class="inline-code">delete</code>: Deallocates memory previously allocated by <code class="inline-code">new</code> (for single objects).</li>
                <li><code class="inline-code">delete[]</code>: Deallocates memory for arrays allocated by <code class="inline-code">new[]</code>.</li>
            </ul>
<pre><code class="language-cpp"><span class="cpp-type">int</span> <span class="cpp-operator">*</span>dynPtr = <span class="cpp-keyword">new</span> <span class="cpp-type">int</span>; <span class="cpp-comment">// Allocate memory for one int</span>
<span class="cpp-operator">*</span>dynPtr = <span class="cpp-number">100</span>;
std::cout &lt;&lt; <span class="cpp-string">"Dynamically allocated int: "</span> &lt;&lt; <span class="cpp-operator">*</span>dynPtr &lt;&lt; std::endl;
<span class="cpp-keyword">delete</span> dynPtr;   <span class="cpp-comment">// Deallocate the memory</span>
dynPtr = <span class="cpp-keyword">nullptr</span>; <span class="cpp-comment">// Good practice to set pointer to nullptr after delete</span>

<span class="cpp-type">int</span> <span class="cpp-operator">*</span>dynArray = <span class="cpp-keyword">new</span> <span class="cpp-type">int</span>[<span class="cpp-number">5</span>]; <span class="cpp-comment">// Allocate memory for an array of 5 ints</span>
dynArray[<span class="cpp-number">0</span>] = <span class="cpp-number">1</span>;
<span class="cpp-comment">// ...</span>
<span class="cpp-keyword">delete</span>[] dynArray; <span class="cpp-comment">// Deallocate the array memory</span>
dynArray = <span class="cpp-keyword">nullptr</span>;
</code></pre>
            <p class="warning">Failing to <code class="inline-code">delete</code> dynamically allocated memory leads to memory leaks. Dereferencing a null pointer or a dangling pointer (pointer to deallocated memory) causes undefined behavior (often crashes). Modern C++ often uses smart pointers (e.g., <code class="inline-code">std::unique_ptr</code>, <code class="inline-code">std::shared_ptr</code> from <code class="inline-code">&lt;memory&gt;</code>) to manage dynamic memory automatically and more safely.</p>
        </section>

        <section id="oop-core">
            <h2>Object-Oriented Programming (OOP) in C++</h2>
            <p>OOP is a paradigm centered around "objects" which combine data and methods.</p>
            <h3>1. Classes and Objects</h3>
            <ul>
                <li><strong>Class:</strong> A blueprint for creating objects. Defines attributes (member variables) and methods (member functions).</li>
                <li><strong>Object:</strong> An instance of a class.</li>
                <li><strong>Access Specifiers:</strong>
                    <ul>
                        <li><code class="inline-code">public</code>: Members are accessible from outside the class.</li>
                        <li><code class="inline-code">private</code>: Members are accessible only by member functions of the class (and friend functions/classes). Default for class members.</li>
                        <li><code class="inline-code">protected</code>: Members are accessible by member functions of the class, derived classes, and friend functions/classes.</li>
                    </ul>
                </li>
            </ul>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-preprocessor">#include &lt;string&gt;</span>

<span class="cpp-keyword">class</span> Dog {
<span class="cpp-keyword">public</span>: <span class="cpp-comment">// Access specifier</span>
    <span class="cpp-comment">// Attributes (member variables)</span>
    std::string name;
    <span class="cpp-type">int</span> age;

    <span class="cpp-comment">// Constructor: Special method to initialize objects</span>
    Dog(std::string n, <span class="cpp-type">int</span> a) {
        name = n;
        age = a;
        std::cout &lt;&lt; name &lt;&lt; <span class="cpp-string">" the dog is created!"</span> &lt;&lt; std::endl;
    }

    <span class="cpp-comment">// Destructor: Called when an object is destroyed</span>
    <span class="cpp-operator">~</span>Dog() {
        std::cout &lt;&lt; name &lt;&lt; <span class="cpp-string">" the dog is destroyed."</span> &lt;&lt; std::endl;
    }

    <span class="cpp-comment">// Method (member function)</span>
    <span class="cpp-type">void</span> bark() {
        std::cout &lt;&lt; name &lt;&lt; <span class="cpp-string">" says: Woof!"</span> &lt;&lt; std::endl;
    }

    <span class="cpp-type">void</span> displayDetails() {
        std::cout &lt;&lt; <span class="cpp-string">"Name: "</span> &lt;&lt; name &lt;&lt; <span class="cpp-string">", Age: "</span> &lt;&lt; age &lt;&lt; std::endl;
    }
}; <span class="cpp-comment">// Semicolon is important after class definition</span>

<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    <span class="cpp-comment">// Create Dog objects (instances)</span>
    Dog dog1(<span class="cpp-string">"Buddy"</span>, <span class="cpp-number">3</span>);
    Dog dog2(<span class="cpp-string">"Lucy"</span>, <span class="cpp-number">5</span>);

    dog1.bark();
    dog2.displayDetails();

    <span class="cpp-comment">// Objects dog1 and dog2 will be destroyed when main() ends</span>
    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}
</code></pre>
            <p>The <code class="inline-code">this</code> pointer is an implicit pointer available in non-static member functions, pointing to the object on which the function was called. E.g., <code class="inline-code">this->name = n;</code></p>

            <h3>2. Encapsulation</h3>
            <p>Bundling data and methods within a class and controlling access (data hiding) using access specifiers. Typically, member variables are <code class="inline-code">private</code>, and <code class="inline-code">public</code> getter/setter methods are provided.</p>

            <h3>3. Inheritance</h3>
            <p>Creating new classes (derived/child) from existing classes (base/parent). <code class="inline-code">class DerivedClass : access_specifier BaseClass { ... };</code></p>
<pre><code class="language-cpp"><span class="cpp-keyword">class</span> Animal {
<span class="cpp-keyword">public</span>:
    std::string name;
    Animal(std::string n) : name(n) {} <span class="cpp-comment">// Constructor with initializer list</span>
    <span class="cpp-type">void</span> eat() { std::cout &lt;&lt; name &lt;&lt; <span class="cpp-string">" is eating."</span> &lt;&lt; std::endl; }
};

<span class="cpp-keyword">class</span> Cat : <span class="cpp-keyword">public</span> Animal { <span class="cpp-comment">// Cat inherits publicly from Animal</span>
<span class="cpp-keyword">public</span>:
    Cat(std::string n) : Animal(n) {} <span class="cpp-comment">// Call base class constructor</span>
    <span class="cpp-type">void</span> meow() { std::cout &lt;&lt; name &lt;&lt; <span class="cpp-string">" says: Meow!"</span> &lt;&lt; std::endl; }
};
</code></pre>

            <h3>4. Polymorphism</h3>
            <p>"Many forms." Allows treating objects of different derived classes through a common base class interface.</p>
            <ul>
                <li><strong>Compile-time (Static) Polymorphism:</strong> Achieved via function overloading and operator overloading.</li>
                <li><strong>Run-time (Dynamic) Polymorphism:</strong> Achieved via <strong>virtual functions</strong>.
                    <ul>
                        <li>A <code class="inline-code">virtual</code> function in a base class can be overridden by a derived class.</li>
                        <li>When called through a base class pointer or reference to a derived class object, the derived class's version is executed.</li>
                        <li>A <strong>pure virtual function</strong> (<code class="inline-code">virtual void func() = 0;</code>) makes a class abstract (cannot be instantiated). Derived classes must implement pure virtual functions.</li>
                    </ul>
                </li>
            </ul>
<pre><code class="language-cpp"><span class="cpp-keyword">class</span> Shape {
<span class="cpp-keyword">public</span>:
    <span class="cpp-keyword">virtual</span> <span class="cpp-type">void</span> draw() { <span class="cpp-comment">// Virtual function</span>
        std::cout &lt;&lt; <span class="cpp-string">"Drawing a generic shape."</span> &lt;&lt; std::endl;
    }
    <span class="cpp-keyword">virtual</span> <span class="cpp-operator">~</span>Shape() {} <span class="cpp-comment">// Virtual destructor: important for proper cleanup with polymorphism!</span>
};

<span class="cpp-keyword">class</span> Circle : <span class="cpp-keyword">public</span> Shape {
<span class="cpp-keyword">public</span>:
    <span class="cpp-type">void</span> draw() <span class="cpp-keyword">override</span> { <span class="cpp-comment">// C++11 override specifier (good practice)</span>
        std::cout &lt;&lt; <span class="cpp-string">"Drawing a circle."</span> &lt;&lt; std::endl;
    }
};

<span class="cpp-comment">// In main:</span>
Shape<span class="cpp-operator">*</span> ptrShape = <span class="cpp-keyword">new</span> Circle();
ptrShape<span class="cpp-operator">-&gt;</span>draw(); <span class="cpp-comment">// Calls Circle's draw() due to virtual function</span>
<span class="cpp-keyword">delete</span> ptrShape;
</code></pre>
        </section>

        <section id="stl-intro">
            <h2>Brief Introduction to the Standard Template Library (STL)</h2>
            <p>The STL is a powerful part of the C++ Standard Library providing pre-built data structures (containers) and algorithms.</p>
            <h3>Containers</h3>
            <p>Generic data structures.</p>
            <ul>
                <li><strong>Sequence Containers:</strong>
                    <ul>
                        <li><code class="inline-code">std::vector</code>: Dynamic array (resizable). Most commonly used. From <code class="inline-code">&lt;vector&gt;</code>.
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;vector&gt;</span>
<span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-comment">// ...</span>
std::vector&lt;<span class="cpp-type">int</span>&gt; vec;
vec.push_back(<span class="cpp-number">10</span>);
vec.push_back(<span class="cpp-number">20</span>);
<span class="cpp-keyword">for</span> (<span class="cpp-type">int</span> val : vec) { std::cout &lt;&lt; val &lt;&lt; <span class="cpp-string">" "</span>; } <span class="cpp-comment">// 10 20</span>
</code></pre>
                        </li>
                        <li><code class="inline-code">std::list</code>: Doubly-linked list. Efficient insertions/deletions. From <code class="inline-code">&lt;list&gt;</code>.</li>
                        <li><code class="inline-code">std::deque</code>: Double-ended queue. From <code class="inline-code">&lt;deque&gt;</code>.</li>
                        <li><code class="inline-code">std::array</code>: Fixed-size array (C++11). From <code class="inline-code">&lt;array&gt;</code>.</li>
                    </ul>
                </li>
                <li><strong>Associative Containers:</strong>
                    <ul>
                        <li><code class="inline-code">std::set</code>: Stores unique elements, sorted by default. From <code class="inline-code">&lt;set&gt;</code>.</li>
                        <li><code class="inline-code">std::map</code>: Stores key-value pairs, keys are unique and sorted. From <code class="inline-code">&lt;map&gt;</code>.
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;map&gt;</span>
<span class="cpp-preprocessor">#include &lt;string&gt;</span>
<span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-comment">// ...</span>
std::map&lt;std::string, <span class="cpp-type">int</span>&gt; ages;
ages[<span class="cpp-string">"Alice"</span>] = <span class="cpp-number">30</span>;
ages[<span class="cpp-string">"Bob"</span>] = <span class="cpp-number">25</span>;
std::cout &lt;&lt; <span class="cpp-string">"Alice's age: "</span> &lt;&lt; ages[<span class="cpp-string">"Alice"</span>] &lt;&lt; std::endl;
</code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Unordered Associative Containers (C++11):</strong> Hash table based. Faster lookups on average, but no ordering. E.g., <code class="inline-code">std::unordered_set</code>, <code class="inline-code">std::unordered_map</code>.</li>
            </ul>
            <h3>Iterators</h3>
            <p>Objects that act like pointers to traverse elements in containers. From <code class="inline-code">&lt;iterator&gt;</code>.</p>
            <h3>Algorithms</h3>
            <p>Functions for common operations on containers (e.g., sorting, searching, counting). From <code class="inline-code">&lt;algorithm&gt;</code>.</p>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;vector&gt;</span>
<span class="cpp-preprocessor">#include &lt;algorithm&gt;</span> <span class="cpp-comment">// For std::sort</span>
<span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-comment">// ...</span>
std::vector&lt;<span class="cpp-type">int</span>&gt; numbers = {<span class="cpp-number">5</span>, <span class="cpp-number">1</span>, <span class="cpp-number">4</span>, <span class="cpp-number">2</span>, <span class="cpp-number">8</span>};
std::sort(numbers.begin(), numbers.end()); <span class="cpp-comment">// Sorts the vector</span>
<span class="cpp-keyword">for</span> (<span class="cpp-type">int</span> n : numbers) { std::cout &lt;&lt; n &lt;&lt; <span class="cpp-string">" "</span>; } <span class="cpp-comment">// 1 2 4 5 8</span>
</code></pre>
        </section>

        <section id="exception-handling">
            <h2>Exception Handling</h2>
            <p>Mechanism to handle runtime errors (exceptions) gracefully.</p>
            <ul>
                <li><code class="inline-code">try</code>: Block of code that might throw an exception.</li>
                <li><code class="inline-code">catch</code>: Block of code to handle a specific type of exception.</li>
                <li><code class="inline-code">throw</code>: Used to "throw" or signal an exception.</li>
            </ul>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-preprocessor">#include &lt;stdexcept&gt;</span> <span class="cpp-comment">// For standard exceptions like std::runtime_error</span>

<span class="cpp-type">double</span> <span class="cpp-function">divide</span>(<span class="cpp-type">double</span> numerator, <span class="cpp-type">double</span> denominator) {
    <span class="cpp-keyword">if</span> (denominator == <span class="cpp-number">0</span>) {
        <span class="cpp-keyword">throw</span> std::runtime_error(<span class="cpp-string">"Division by zero error!"</span>);
    }
    <span class="cpp-keyword">return</span> numerator / denominator;
}

<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    <span class="cpp-keyword">try</span> {
        std::cout &lt;&lt; divide(<span class="cpp-number">10.0</span>, <span class="cpp-number">2.0</span>) &lt;&lt; std::endl; <span class="cpp-comment">// 5</span>
        std::cout &lt;&lt; divide(<span class="cpp-number">5.0</span>, <span class="cpp-number">0.0</span>) &lt;&lt; std::endl;  <span class="cpp-comment">// Throws exception</span>
        std::cout &lt;&lt; <span class="cpp-string">"This won't be printed."</span> &lt;&lt; std::endl;
    } <span class="cpp-keyword">catch</span> (<span class="cpp-keyword">const</span> std::runtime_error<span class="cpp-operator">&amp;</span> e) { <span class="cpp-comment">// Catch by const reference</span>
        std::cerr &lt;&lt; <span class="cpp-string">"Exception caught: "</span> &lt;&lt; e.what() &lt;&lt; std::endl; <span class="cpp-comment">// e.what() gives the error message</span>
    } <span class="cpp-keyword">catch</span> (...) { <span class="cpp-comment">// Catch-all block for any other exception type</span>
        std::cerr &lt;&lt; <span class="cpp-string">"An unknown exception occurred."</span> &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; <span class="cpp-string">"Program continues..."</span> &lt;&lt; std::endl;
    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}
</code></pre>
        </section>

        <section id="file-io-intro">
            <h2>Brief Introduction to File I/O</h2>
            <p>C++ uses streams for file input/output, primarily from the <code class="inline-code">&lt;fstream&gt;</code> library.</p>
            <ul>
                <li><code class="inline-code">std::ofstream</code>: Output file stream (for writing to files).</li>
                <li><code class="inline-code">std::ifstream</code>: Input file stream (for reading from files).</li>
                <li><code class="inline-code">std::fstream</code>: File stream for both reading and writing.</li>
            </ul>
            <h3>Writing to a File</h3>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-preprocessor">#include &lt;fstream&gt;</span> <span class="cpp-comment">// For file operations</span>
<span class="cpp-preprocessor">#include &lt;string&gt;</span>

<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    std::ofstream outFile(<span class="cpp-string">"example.txt"</span>); <span class="cpp-comment">// Creates/opens file for writing (overwrites if exists)</span>
    <span class="cpp-comment">// To append: std::ofstream outFile("example.txt", std::ios::app);</span>

    <span class="cpp-keyword">if</span> (outFile.is_open()) {
        outFile &lt;&lt; <span class="cpp-string">"Hello from C++ File I/O!"</span> &lt;&lt; std::endl;
        outFile &lt;&lt; <span class="cpp-string">"This is the second line."</span> &lt;&lt; std::endl;
        outFile.close(); <span class="cpp-comment">// Close the file</span>
        std::cout &lt;&lt; <span class="cpp-string">"Successfully wrote to file."</span> &lt;&lt; std::endl;
    } <span class="cpp-keyword">else</span> {
        std::cerr &lt;&lt; <span class="cpp-string">"Unable to open file for writing."</span> &lt;&lt; std::endl;
    }
    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}
</code></pre>
            <h3>Reading from a File</h3>
<pre><code class="language-cpp"><span class="cpp-preprocessor">#include &lt;iostream&gt;</span>
<span class="cpp-preprocessor">#include &lt;fstream&gt;</span>
<span class="cpp-preprocessor">#include &lt;string&gt;</span>

<span class="cpp-keyword">int</span> <span class="cpp-function">main</span>() {
    std::ifstream inFile(<span class="cpp-string">"example.txt"</span>); <span class="cpp-comment">// Opens file for reading</span>
    std::string line;

    <span class="cpp-keyword">if</span> (inFile.is_open()) {
        std::cout &lt;&lt; <span class="cpp-string">"File content:"</span> &lt;&lt; std::endl;
        <span class="cpp-keyword">while</span> (std::getline(inFile, line)) { <span class="cpp-comment">// Read line by line</span>
            std::cout &lt;&lt; line &lt;&lt; std::endl;
        }
        inFile.close(); <span class="cpp-comment">// Close the file</span>
    } <span class="cpp-keyword">else</span> {
        std::cerr &lt;&lt; <span class="cpp-string">"Unable to open file for reading."</span> &lt;&lt; std::endl;
    }
    <span class="cpp-keyword">return</span> <span class="cpp-number">0</span>;
}
</code></pre>
            <p class="important">Always check if the file was opened successfully using <code class="inline-code">is_open()</code> and remember to <code class="inline-code">close()</code> files when done. RAII (Resource Acquisition Is Initialization) techniques using objects whose destructors close files can also manage this automatically.</p>
        </section>

        <section id="next-steps">
            <h2>Next Steps</h2>
            <p>Well done on getting through this introduction to C++! It's a language with a steep learning curve but immense power.</p>
            <p>To continue your C++ journey:</p>
            <ul>
                <li><strong>Practice Consistently:</strong> Solve problems on platforms like HackerRank, LeetCode, Codeforces, or Project Euler.</li>
                <li><strong>Deep Dive into OOP:</strong> Explore advanced OOP concepts like multiple inheritance, virtual inheritance, abstract classes in depth, design patterns.</li>
                <li><strong>Master the STL:</strong> Understand different containers, iterators, and algorithms thoroughly. Learn about their performance characteristics.</li>
                <li><strong>Memory Management:</strong> Study smart pointers (<code class="inline-code">std::unique_ptr</code>, <code class="inline-code">std::shared_ptr</code>, <code class="inline-code">std::weak_ptr</code>) for safer memory management.</li>
                <li><strong>Modern C++ Features:</strong> Learn about features from C++11, C++14, C++17, C++20, and beyond (e.g., lambdas, move semantics, concurrency features, modules, concepts).</li>
                <li><strong>Build Projects:</strong>
                    <ul>
                        <li>Command-line applications (e.g., text processing tools, simple games).</li>
                        <li>Small GUI applications (using libraries like Qt or wxWidgets).</li>
                        <li>Contribute to open-source projects.</li>
                    </ul>
                </li>
                <li><strong>Learn Build Systems:</strong> CMake is widely used for managing C++ projects. Make is also common.</li>
                <li><strong>Debugging:</strong> Become proficient with a debugger (like GDB, LLDB, or the debugger in your IDE).</li>
                <li><strong>Explore Specific Domains:</strong>
                    <ul>
                        <li><strong>Game Development:</strong> Engines like Unreal Engine (C++) or Godot (C++ core).</li>
                        <li><strong>Systems Programming:</strong> Operating system components, drivers.</li>
                        <li><strong>High-Performance Computing (HPC).</strong></li>
                        <li><strong>Embedded Systems.</strong></li>
                        <li><strong>Financial Quantitative Analysis.</strong></li>
                    </ul>
                </li>
                <li><strong>Read Books:</strong>
                    <ul>
                        <li>"A Tour of C++" by Bjarne Stroustrup (good overview).</li>
                        <li>"Programming: Principles and Practice Using C++" by Bjarne Stroustrup (more in-depth for beginners/intermediate).</li>
                        <li>"Effective Modern C++" by Scott Meyers (for more advanced topics on modern C++).</li>
                    </ul>
                </li>
                <li><strong>Refer to cppreference.com:</strong> An excellent online reference for C++ language and library details.</li>
            </ul>
            <p class="important">C++ is a journey. Be patient, practice a lot, and build things!</p>
            <p>Happy coding in C++!</p>
        </section>

    </div>

    <script>
        // Simple script for active link highlighting in sidebar
        const sections = document.querySelectorAll('#main-content section');
        const navLinks = document.querySelectorAll('#sidebar ul li a');

        window.onscroll = () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (pageYOffset >= sectionTop - 60) { // 60px offset for better UX
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href').substring(1) === current) {
                    link.classList.add('active');
                }
            });
        };
        // Activate the first link by default or based on hash
        function activateInitialLink() {
            const hash = window.location.hash;
            let activeLinkFound = false;
            if (hash) {
                navLinks.forEach(link => {
                    if (link.getAttribute('href') === hash) {
                        link.classList.add('active');
                        activeLinkFound = true;
                    }
                });
            }
            if (!activeLinkFound && navLinks.length > 0) {
                navLinks[0].classList.add('active'); // Default to first if no hash or match
            }
        }
        activateInitialLink();
        window.addEventListener('hashchange', activateInitialLink); // For when user clicks links
    </script>

</body>
</html>